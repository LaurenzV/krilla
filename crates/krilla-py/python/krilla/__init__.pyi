"""Type stubs for krilla Python bindings."""

from __future__ import annotations

from collections.abc import Sequence
from enum import IntEnum
from typing import Any, Union

# Re-export high-level text API
from krilla.text import Glyph as Glyph
from krilla.text import glyphs_to_text as glyphs_to_text

__version__: str

# Feature detection
def has_image_support() -> bool: ...
def has_text_support() -> bool: ...

# Exceptions
class KrillaError(Exception): ...
class FontError(KrillaError): ...
class ValidationError(KrillaError): ...
class ImageError(KrillaError): ...

# Numeric types
class NormalizedF32:
    """A floating-point number normalized to the range [0.0, 1.0]."""
    def __init__(self, value: float) -> None: ...
    @staticmethod
    def zero() -> NormalizedF32: ...
    @staticmethod
    def one() -> NormalizedF32: ...
    def get(self) -> float: ...
    def __float__(self) -> float: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

# Geometry types
class Point:
    """A 2D point."""
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @staticmethod
    def from_xy(x: float, y: float) -> Point: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class Size:
    """A 2D size with width and height."""
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    @staticmethod
    def from_wh(width: float, height: float) -> Size: ...
    def __eq__(self, other: object) -> bool: ...

class Rect:
    """A rectangle defined by left, top, right, bottom coordinates."""
    @property
    def left(self) -> float: ...
    @property
    def top(self) -> float: ...
    @property
    def right(self) -> float: ...
    @property
    def bottom(self) -> float: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...
    @staticmethod
    def from_xywh(x: float, y: float, width: float, height: float) -> Rect: ...
    @staticmethod
    def from_ltrb(left: float, top: float, right: float, bottom: float) -> Rect: ...
    def transform(self, transform: Transform) -> Rect | None: ...
    def __eq__(self, other: object) -> bool: ...

class Transform:
    """A 2D affine transformation matrix."""
    @property
    def sx(self) -> float: ...
    @property
    def sy(self) -> float: ...
    @property
    def kx(self) -> float: ...
    @property
    def ky(self) -> float: ...
    @property
    def tx(self) -> float: ...
    @property
    def ty(self) -> float: ...
    @staticmethod
    def identity() -> Transform: ...
    @staticmethod
    def from_row(
        sx: float, ky: float, kx: float, sy: float, tx: float, ty: float
    ) -> Transform: ...
    @staticmethod
    def from_translate(tx: float, ty: float) -> Transform: ...
    @staticmethod
    def from_scale(sx: float, sy: float) -> Transform: ...
    @staticmethod
    def from_skew(kx: float, ky: float) -> Transform: ...
    @staticmethod
    def from_rotate(angle: float) -> Transform: ...
    @staticmethod
    def from_rotate_at(angle: float, tx: float, ty: float) -> Transform: ...
    def invert(self) -> Transform | None: ...
    def __eq__(self, other: object) -> bool: ...

class Path:
    """A geometric path consisting of line segments and curves."""
    def transform(self, transform: Transform) -> Path | None: ...

class PathBuilder:
    """Builder for creating geometric paths."""
    def __init__(self) -> None: ...
    def move_to(self, x: float, y: float) -> None: ...
    def line_to(self, x: float, y: float) -> None: ...
    def quad_to(self, x1: float, y1: float, x: float, y: float) -> None: ...
    def cubic_to(
        self, x1: float, y1: float, x2: float, y2: float, x: float, y: float
    ) -> None: ...
    def close(self) -> None: ...
    def push_rect(self, rect: Rect) -> None: ...
    def finish(self) -> Path: ...

# Enums
class FillRule(IntEnum):
    NonZero = ...
    EvenOdd = ...

class LineCap(IntEnum):
    Butt = ...
    Round = ...
    Square = ...

class LineJoin(IntEnum):
    Miter = ...
    Round = ...
    Bevel = ...

class SpreadMethod(IntEnum):
    Pad = ...
    Reflect = ...
    Repeat = ...

class BlendMode(IntEnum):
    Normal = ...
    Multiply = ...
    Screen = ...
    Overlay = ...
    Darken = ...
    Lighten = ...
    ColorDodge = ...
    ColorBurn = ...
    HardLight = ...
    SoftLight = ...
    Difference = ...
    Exclusion = ...
    Hue = ...
    Saturation = ...
    Color = ...
    Luminosity = ...

class MaskType(IntEnum):
    Luminosity = ...
    Alpha = ...

# Accessibility/Tagging types
class ArtifactType(IntEnum):
    """Type of artifact in a PDF document."""

    Header = ...
    Footer = ...
    Page = ...
    Other = ...

class Location:
    """A location identifier for tracking render operations."""
    def __init__(self, value: int) -> None:
        """Create a new location from a positive integer. Raises ValueError if zero."""
        ...
    def get(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class SpanTag:
    """A span tag with text properties for accessibility."""

    lang: str | None
    alt_text: str | None
    expanded: str | None
    actual_text: str | None
    def __init__(
        self,
        lang: str | None = None,
        alt_text: str | None = None,
        expanded: str | None = None,
        actual_text: str | None = None,
    ) -> None: ...

class ContentTag:
    """A content tag for accessibility marking."""
    @staticmethod
    def artifact(artifact_type: ArtifactType) -> ContentTag: ...
    @staticmethod
    def span(tag: SpanTag) -> ContentTag: ...
    @staticmethod
    def other() -> ContentTag: ...

class Identifier:
    """An identifier returned from start_tagged."""
    def is_dummy(self) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class TextDirection(IntEnum):
    Auto = ...
    LeftToRight = ...
    RightToLeft = ...

# Color types
class color:
    @staticmethod
    def rgb(red: int, green: int, blue: int) -> RgbColor: ...
    @staticmethod
    def luma(lightness: int) -> LumaColor: ...
    @staticmethod
    def cmyk(cyan: int, magenta: int, yellow: int, black: int) -> CmykColor: ...

    class RgbColor:
        def __init__(self, red: int, green: int, blue: int) -> None: ...
        @property
        def red(self) -> int: ...
        @property
        def green(self) -> int: ...
        @property
        def blue(self) -> int: ...
        @staticmethod
        def black() -> RgbColor: ...
        @staticmethod
        def white() -> RgbColor: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...

    class LumaColor:
        def __init__(self, lightness: int) -> None: ...
        @property
        def lightness(self) -> int: ...
        @staticmethod
        def black() -> LumaColor: ...
        @staticmethod
        def white() -> LumaColor: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...

    class CmykColor:
        def __init__(
            self, cyan: int, magenta: int, yellow: int, black: int
        ) -> None: ...
        @property
        def cyan(self) -> int: ...
        @property
        def magenta(self) -> int: ...
        @property
        def yellow(self) -> int: ...
        @property
        def black(self) -> int: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...

    class Color:
        @staticmethod
        def from_rgb(color: RgbColor) -> Color: ...
        @staticmethod
        def from_luma(color: LumaColor) -> Color: ...
        @staticmethod
        def from_cmyk(color: CmykColor) -> Color: ...
        def __eq__(self, other: object) -> bool: ...
        def __hash__(self) -> int: ...

# Re-export color types at module level
RgbColor = color.RgbColor
LumaColor = color.LumaColor
CmykColor = color.CmykColor
Color = color.Color

# Paint types
PaintType = Union[
    color.RgbColor,
    color.LumaColor,
    color.CmykColor,
    color.Color,
    "LinearGradient",
    "RadialGradient",
    "SweepGradient",
    "Pattern",
]

class Stop:
    """A gradient color stop."""
    def __init__(
        self,
        offset: NormalizedF32,
        color: color.Color,
        opacity: NormalizedF32 | None = None,
    ) -> None: ...
    @property
    def offset(self) -> NormalizedF32: ...
    @property
    def color(self) -> color.Color: ...
    @property
    def opacity(self) -> NormalizedF32: ...

class LinearGradient:
    """A linear gradient paint."""
    def __init__(
        self,
        x1: float,
        y1: float,
        x2: float,
        y2: float,
        stops: Sequence[Stop],
        transform: Transform | None = None,
        spread_method: SpreadMethod | None = None,
        anti_alias: bool = False,
    ) -> None: ...
    def into_paint(self) -> Paint: ...

class RadialGradient:
    """A radial gradient paint."""
    def __init__(
        self,
        fx: float,
        fy: float,
        fr: float,
        cx: float,
        cy: float,
        cr: float,
        stops: Sequence[Stop],
        transform: Transform | None = None,
        spread_method: SpreadMethod | None = None,
        anti_alias: bool = False,
    ) -> None: ...
    def into_paint(self) -> Paint: ...

class SweepGradient:
    """A sweep (conic) gradient paint."""
    def __init__(
        self,
        cx: float,
        cy: float,
        start_angle: float,
        end_angle: float,
        stops: Sequence[Stop],
        transform: Transform | None = None,
        spread_method: SpreadMethod | None = None,
        anti_alias: bool = False,
    ) -> None: ...
    def into_paint(self) -> Paint: ...

class Paint:
    """A paint value for fills and strokes."""
    @staticmethod
    def from_rgb(color: color.RgbColor) -> Paint: ...
    @staticmethod
    def from_luma(color: color.LumaColor) -> Paint: ...
    @staticmethod
    def from_cmyk(color: color.CmykColor) -> Paint: ...
    @staticmethod
    def from_color(color: color.Color) -> Paint: ...
    @staticmethod
    def from_linear_gradient(gradient: LinearGradient) -> Paint: ...
    @staticmethod
    def from_radial_gradient(gradient: RadialGradient) -> Paint: ...
    @staticmethod
    def from_sweep_gradient(gradient: SweepGradient) -> Paint: ...
    @staticmethod
    def from_pattern(pattern: Pattern) -> Paint: ...

class StrokeDash:
    """A dash pattern for strokes."""
    def __init__(self, array: Sequence[float], offset: float) -> None: ...

class Fill:
    """Fill properties for drawing paths."""
    def __init__(
        self,
        paint: Paint,
        opacity: NormalizedF32 | None = None,
        rule: FillRule | None = None,
    ) -> None: ...
    @property
    def opacity(self) -> NormalizedF32: ...
    @property
    def rule(self) -> FillRule: ...

class Stroke:
    """Stroke properties for drawing paths."""
    def __init__(
        self,
        paint: Paint,
        width: float | None = None,
        miter_limit: float | None = None,
        line_cap: LineCap | None = None,
        line_join: LineJoin | None = None,
        opacity: NormalizedF32 | None = None,
        dash: StrokeDash | None = None,
    ) -> None: ...
    @property
    def width(self) -> float: ...
    @property
    def opacity(self) -> NormalizedF32: ...
    @property
    def line_cap(self) -> LineCap: ...
    @property
    def line_join(self) -> LineJoin: ...
    @property
    def miter_limit(self) -> float: ...

# Text types
class Font:
    """A font for rendering text."""
    @staticmethod
    def new(data: bytes, index: int) -> Font | None: ...
    @staticmethod
    def new_variable(
        data: bytes, index: int, variations: Sequence[tuple[str, float]]
    ) -> Font | None: ...
    def units_per_em(self) -> float: ...
    def ascent(self) -> float: ...
    def descent(self) -> float: ...
    def cap_height(self) -> float | None: ...

class GlyphId:
    """A glyph identifier."""
    def __init__(self, id: int) -> None: ...
    def to_u32(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...

class KrillaGlyph:
    """A glyph with positioning information for low-level text rendering."""

    glyph_id: GlyphId
    text_start: int
    text_end: int
    x_advance: float
    x_offset: float
    y_offset: float
    y_advance: float
    def __init__(
        self,
        glyph_id: GlyphId,
        x_advance: float,
        text_start: int,
        text_end: int,
        x_offset: float = 0.0,
        y_offset: float = 0.0,
        y_advance: float = 0.0,
    ) -> None: ...

# Image types (feature-gated)
class Image:
    """A raster image for embedding in PDFs."""
    @staticmethod
    def from_png(data: bytes, interpolate: bool = True) -> Image: ...
    @staticmethod
    def from_jpeg(data: bytes, interpolate: bool = True) -> Image: ...
    @staticmethod
    def from_gif(data: bytes, interpolate: bool = True) -> Image: ...
    @staticmethod
    def from_webp(data: bytes, interpolate: bool = True) -> Image: ...
    @staticmethod
    def from_rgba8(data: bytes, width: int, height: int) -> Image: ...
    @staticmethod
    def from_pil(image: Any, interpolate: bool = True) -> Image:
        """Convert a PIL/Pillow image to a krilla Image.

        Args:
            image: A PIL.Image.Image object or any object with a .save() method
            interpolate: Whether to interpolate when scaling

        Returns:
            A krilla Image object
        """
        ...
    def size(self) -> tuple[int, int]: ...
    @property
    def width(self) -> int: ...
    @property
    def height(self) -> int: ...

# Stream and mask types
class StreamBuilder:
    """Builder for creating streams."""
    def __init__(self, size: Size) -> None: ...
    def surface(self) -> StreamSurface: ...
    def finish(self) -> Stream: ...

class StreamSurface:
    """A drawing surface for a StreamBuilder."""
    def set_fill(self, fill: Fill | None = None) -> None: ...
    def get_fill(self) -> Fill | None: ...
    def set_stroke(self, stroke: Stroke | None = None) -> None: ...
    def get_stroke(self) -> Stroke | None: ...
    def draw_path(self, path: Path) -> None: ...
    def push_transform(self, transform: Transform) -> None: ...
    def push_clip_path(self, path: Path, clip_rule: FillRule) -> None: ...
    def push_opacity(self, opacity: NormalizedF32) -> None: ...
    def push_isolated(self) -> None: ...
    def pop(self) -> None: ...
    def finish(self) -> None: ...
    def __enter__(self) -> StreamSurface: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> None: ...

class Stream:
    """A content stream for masks and patterns."""

    pass

class Mask:
    """A mask for clipping or transparency effects."""
    def __init__(self, stream: Stream, mask_type: MaskType) -> None: ...

class Pattern:
    """A pattern paint."""
    def __init__(
        self,
        stream: Stream,
        width: float,
        height: float,
        transform: Transform | None = None,
    ) -> None: ...
    @property
    def width(self) -> float: ...
    @property
    def height(self) -> float: ...

# Configuration types
class PdfVersion(IntEnum):
    Pdf14 = ...
    Pdf15 = ...
    Pdf16 = ...
    Pdf17 = ...
    Pdf20 = ...
    def as_str(self) -> str: ...

class Validator(IntEnum):
    none = ...
    A1A = ...
    A1B = ...
    A2A = ...
    A2B = ...
    A2U = ...
    A3A = ...
    A3B = ...
    A3U = ...
    A4 = ...
    A4F = ...
    A4E = ...
    UA1 = ...
    def compatible_with_version(self, version: PdfVersion) -> bool: ...
    def recommended_version(self) -> PdfVersion: ...

class Configuration:
    """PDF generation configuration."""
    def __init__(self) -> None: ...
    @staticmethod
    def with_validator(validator: Validator) -> Configuration: ...
    @staticmethod
    def with_version(version: PdfVersion) -> Configuration: ...
    @staticmethod
    def with_validator_and_version(
        validator: Validator, version: PdfVersion
    ) -> Configuration | None: ...
    @property
    def validator(self) -> Validator: ...
    @property
    def version(self) -> PdfVersion: ...

class SerializeSettings:
    """Settings for PDF serialization."""
    def __init__(self) -> None: ...
    @staticmethod
    def with_configuration(configuration: Configuration) -> SerializeSettings: ...

# Page settings
class PageSettings:
    """Settings for a PDF page."""
    def __init__(self, size: Size) -> None: ...
    @staticmethod
    def from_wh(width: float, height: float) -> PageSettings: ...
    def with_media_box(self, media_box: Rect | None) -> PageSettings: ...
    def with_crop_box(self, crop_box: Rect | None) -> PageSettings: ...
    def with_bleed_box(self, bleed_box: Rect | None) -> PageSettings: ...
    def with_trim_box(self, trim_box: Rect | None) -> PageSettings: ...
    def with_art_box(self, art_box: Rect | None) -> PageSettings: ...

# Context manager types for graphics state operations
class TransformContext:
    """Context manager for applying transforms with automatic pop."""
    def __enter__(self) -> TransformContext: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> bool: ...

class BlendModeContext:
    """Context manager for applying blend modes with automatic pop."""
    def __enter__(self) -> BlendModeContext: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> bool: ...

class ClipPathContext:
    """Context manager for applying clip paths with automatic pop."""
    def __enter__(self) -> ClipPathContext: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> bool: ...

class MaskContext:
    """Context manager for applying masks with automatic pop."""
    def __enter__(self) -> MaskContext: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> bool: ...

class OpacityContext:
    """Context manager for applying opacity with automatic pop."""
    def __enter__(self) -> OpacityContext: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> bool: ...

class IsolatedContext:
    """Context manager for isolated transparency groups with automatic pop."""
    def __enter__(self) -> IsolatedContext: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> bool: ...

# Core types
class Surface:
    """A drawing surface for a page or stream."""
    # Fill and stroke
    def set_fill(self, fill: Fill | None = None) -> None: ...
    def get_fill(self) -> Fill | None: ...
    def set_stroke(self, stroke: Stroke | None = None) -> None: ...
    def get_stroke(self) -> Stroke | None: ...
    # Drawing operations
    def draw_path(self, path: Path) -> None: ...
    def draw_glyphs(
        self,
        start: Point,
        glyphs: Sequence[KrillaGlyph],
        font: Font,
        text: str,
        font_size: float,
        outlined: bool = False,
    ) -> None: ...
    def draw_text(
        self,
        start: Point,
        font: Font,
        font_size: float,
        text: str,
        outlined: bool = False,
        direction: TextDirection = ...,
    ) -> None: ...
    def draw_image(self, image: Image, size: Size) -> None: ...
    # Push/pop operations (manual)
    def push_transform(self, transform: Transform) -> None: ...
    def push_blend_mode(self, blend_mode: BlendMode) -> None: ...
    def push_clip_path(self, path: Path, clip_rule: FillRule) -> None: ...
    def push_mask(self, mask: Mask) -> None: ...
    def push_opacity(self, opacity: NormalizedF32) -> None: ...
    def push_isolated(self) -> None: ...
    def pop(self) -> None: ...
    def ctm(self) -> Transform: ...
    # Context manager methods (automatic pop)
    def transform(self, matrix: Transform) -> TransformContext: ...
    def blend_mode(self, mode: BlendMode) -> BlendModeContext: ...
    def clip_path(self, path: Path, fill_rule: FillRule) -> ClipPathContext: ...
    def mask(self, mask_obj: Mask) -> MaskContext: ...
    def opacity(self, opacity_val: NormalizedF32) -> OpacityContext: ...
    def isolated(self) -> IsolatedContext: ...
    # Accessibility/Tagging
    def set_location(self, location: Location) -> None: ...
    def reset_location(self) -> None: ...
    def get_location(self) -> Location | None: ...
    def start_tagged(self, tag: ContentTag) -> Identifier: ...
    def end_tagged(self) -> None: ...
    def start_alt_text(self, text: str) -> None: ...
    def end_alt_text(self) -> None: ...
    # Lifecycle
    def finish(self) -> None: ...
    def __enter__(self) -> Surface: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> None: ...

class Page:
    """A PDF page."""
    def surface(self) -> Surface: ...
    def finish(self) -> None: ...
    def __enter__(self) -> Page: ...
    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> None: ...

class Document:
    """A PDF document builder."""
    def __init__(self) -> None: ...
    @staticmethod
    def new_with(settings: SerializeSettings) -> Document: ...
    def start_page(self) -> Page: ...
    def start_page_with(self, settings: PageSettings) -> Page: ...
    def finish(self) -> bytes: ...
