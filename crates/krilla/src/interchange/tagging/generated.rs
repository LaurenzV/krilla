// This file is automatically generated!
//
// To update it:
// 1. Edit the `generate.toml` file inside of this directory
// 2. Run `cargo run --bin=codegen` from the repository root

/// A tag for group nodes.
#[derive(Clone, Debug, PartialEq)]
pub enum TagKind {
    /// A part of a document that may contain multiple articles or sections.
    Part(Tag<Part>),
    /// An article with largely self-contained content.
    Article(Tag<Article>),
    /// Section of a larger document.
    Section(Tag<Section>),
    /// A paragraph-level quote.
    BlockQuote(Tag<BlockQuote>),
    /// An image or figure caption.
    ///
    /// **Best Practice**: In the tag tree, this should appear
    /// as a sibling after the image (or other) content it describes.
    Caption(Tag<Caption>),
    /// Table of contents.
    ///
    /// **Best Practice**: Should consist of TOCIs or other nested TOCs.
    TOC(Tag<TOC>),
    /// Item in the table of contents.
    ///
    /// **Best Practice**: Should only appear within a TOC. Should only consist of
    /// labels, references, paragraphs and TOCs.
    TOCI(Tag<TOCI>),
    /// Index of the key terms in the document.
    ///
    /// **Best Practice**: Should contain a sequence of text accompanied by
    /// reference elements pointing to their occurrence in the text.
    Index(Tag<Index>),
    /// A paragraph.
    P(Tag<P>),
    /// Heading level `n`, including an optional title of the heading.
    ///
    /// The title is required for some export modes, like for example PDF/UA.
    Hn(Tag<Hn>),
    /// A list.
    ///
    /// **Best practice**: Should consist of an optional caption followed by
    /// list items.
    /// List numbering is only required for PDF/UA, but we just enforce it for always.
    L(Tag<L>),
    /// A list item.
    ///
    /// **Best practice**: Should consist of one or more list labels and/or list bodies.
    LI(Tag<LI>),
    /// Label for a list item.
    Lbl(Tag<Lbl>),
    /// Description of the list item.
    LBody(Tag<LBody>),
    /// A table, with an optional summary describing the purpose and structure.
    ///
    /// **Best practice**: Should consist of an optional table header row,
    /// one or more table body elements and an optional table footer. Can have
    /// caption as the first or last child.
    Table(Tag<Table>),
    /// A table row.
    ///
    /// **Best practice**: May contain table headers cells and table data cells.
    TR(Tag<TR>),
    /// A table header cell.
    TH(Tag<TH>),
    /// A table data cell.
    TD(Tag<TD>),
    /// A table header row group.
    THead(Tag<THead>),
    /// A table data row group.
    TBody(Tag<TBody>),
    /// A table footer row group.
    TFoot(Tag<TFoot>),
    /// An inline quotation.
    InlineQuote(Tag<InlineQuote>),
    /// A foot- or endnote, potentially referred to from within the text.
    ///
    /// **Best practice**: It may have a label as a child.
    Note(Tag<Note>),
    /// A reference to elsewhere in the document.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to a destination in the document, and the second child should consist of
    /// the children that should be associated with that reference.
    Reference(Tag<Reference>),
    /// A reference to the external source of some cited document.
    ///
    /// **Best practice**: It may have a label as a child.
    BibEntry(Tag<BibEntry>),
    /// Computer code.
    Code(Tag<Code>),
    /// A link.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to an URL, and the second child should consist of the children that should
    /// be associated with that link.
    Link(Tag<Link>),
    /// An association between an annotation and the content it belongs to. PDF
    ///
    /// **Best practice**: Should be used for all annotations, except for link annotations and
    /// widget annotations. The first child should be the identifier of a non-link annotation,
    /// and all other subsequent children should be content identifiers associated with that
    /// annotation.
    Annot(Tag<Annot>),
    /// Item of graphical content.
    ///
    /// Providing [`Tag::alt_text`] is required in some export modes, like for example PDF/UA1.
    Figure(Tag<Figure>),
    /// A mathematical formula.
    ///
    /// Providing [`Tag::alt_text`] is required in some export modes, like for example PDF/UA1.
    Formula(Tag<Formula>),
    /// A date or time.
    Datetime(Tag<Datetime>),
    /// A list of terms.
    Terms(Tag<Terms>),
    /// A title.
    Title(Tag<Title>),
}

impl TagKind {
    /// A type erased tag, which allows reading all attributes.
    pub fn as_any(&self) -> &AnyTag {
        match self {
            Self::Part(tag) => tag.as_any(),
            Self::Article(tag) => tag.as_any(),
            Self::Section(tag) => tag.as_any(),
            Self::BlockQuote(tag) => tag.as_any(),
            Self::Caption(tag) => tag.as_any(),
            Self::TOC(tag) => tag.as_any(),
            Self::TOCI(tag) => tag.as_any(),
            Self::Index(tag) => tag.as_any(),
            Self::P(tag) => tag.as_any(),
            Self::Hn(tag) => tag.as_any(),
            Self::L(tag) => tag.as_any(),
            Self::LI(tag) => tag.as_any(),
            Self::Lbl(tag) => tag.as_any(),
            Self::LBody(tag) => tag.as_any(),
            Self::Table(tag) => tag.as_any(),
            Self::TR(tag) => tag.as_any(),
            Self::TH(tag) => tag.as_any(),
            Self::TD(tag) => tag.as_any(),
            Self::THead(tag) => tag.as_any(),
            Self::TBody(tag) => tag.as_any(),
            Self::TFoot(tag) => tag.as_any(),
            Self::InlineQuote(tag) => tag.as_any(),
            Self::Note(tag) => tag.as_any(),
            Self::Reference(tag) => tag.as_any(),
            Self::BibEntry(tag) => tag.as_any(),
            Self::Code(tag) => tag.as_any(),
            Self::Link(tag) => tag.as_any(),
            Self::Annot(tag) => tag.as_any(),
            Self::Figure(tag) => tag.as_any(),
            Self::Formula(tag) => tag.as_any(),
            Self::Datetime(tag) => tag.as_any(),
            Self::Terms(tag) => tag.as_any(),
            Self::Title(tag) => tag.as_any(),
        }
    }

    /// A type erased tag, which allows reading all attributes and additionally
    /// writing all global attributes.
    pub fn as_any_mut(&mut self) -> &mut AnyTag {
        match self {
            Self::Part(tag) => tag.as_any_mut(),
            Self::Article(tag) => tag.as_any_mut(),
            Self::Section(tag) => tag.as_any_mut(),
            Self::BlockQuote(tag) => tag.as_any_mut(),
            Self::Caption(tag) => tag.as_any_mut(),
            Self::TOC(tag) => tag.as_any_mut(),
            Self::TOCI(tag) => tag.as_any_mut(),
            Self::Index(tag) => tag.as_any_mut(),
            Self::P(tag) => tag.as_any_mut(),
            Self::Hn(tag) => tag.as_any_mut(),
            Self::L(tag) => tag.as_any_mut(),
            Self::LI(tag) => tag.as_any_mut(),
            Self::Lbl(tag) => tag.as_any_mut(),
            Self::LBody(tag) => tag.as_any_mut(),
            Self::Table(tag) => tag.as_any_mut(),
            Self::TR(tag) => tag.as_any_mut(),
            Self::TH(tag) => tag.as_any_mut(),
            Self::TD(tag) => tag.as_any_mut(),
            Self::THead(tag) => tag.as_any_mut(),
            Self::TBody(tag) => tag.as_any_mut(),
            Self::TFoot(tag) => tag.as_any_mut(),
            Self::InlineQuote(tag) => tag.as_any_mut(),
            Self::Note(tag) => tag.as_any_mut(),
            Self::Reference(tag) => tag.as_any_mut(),
            Self::BibEntry(tag) => tag.as_any_mut(),
            Self::Code(tag) => tag.as_any_mut(),
            Self::Link(tag) => tag.as_any_mut(),
            Self::Annot(tag) => tag.as_any_mut(),
            Self::Figure(tag) => tag.as_any_mut(),
            Self::Formula(tag) => tag.as_any_mut(),
            Self::Datetime(tag) => tag.as_any_mut(),
            Self::Terms(tag) => tag.as_any_mut(),
            Self::Title(tag) => tag.as_any_mut(),
        }
    }

    /// The tag id.
    pub fn id(&self) -> Option<&TagId> {
        self.as_any().id()
    }

    /// The tag id.
    pub fn set_id(&mut self, id: Option<TagId>) {
        self.as_any_mut().set_id(id);
    }

    /// The tag id.
    pub fn with_id(mut self, id: Option<TagId>) -> Self {
        self.set_id(id);
        self
    }

    /// The language of this tag.
    pub fn lang(&self) -> Option<&str> {
        self.as_any().lang()
    }

    /// The language of this tag.
    pub fn set_lang(&mut self, lang: Option<String>) {
        self.as_any_mut().set_lang(lang);
    }

    /// The language of this tag.
    pub fn with_lang(mut self, lang: Option<String>) -> Self {
        self.set_lang(lang);
        self
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn alt_text(&self) -> Option<&str> {
        self.as_any().alt_text()
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn set_alt_text(&mut self, alt_text: Option<String>) {
        self.as_any_mut().set_alt_text(alt_text);
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn with_alt_text(mut self, alt_text: Option<String>) -> Self {
        self.set_alt_text(alt_text);
        self
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn expanded(&self) -> Option<&str> {
        self.as_any().expanded()
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn set_expanded(&mut self, expanded: Option<String>) {
        self.as_any_mut().set_expanded(expanded);
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn with_expanded(mut self, expanded: Option<String>) -> Self {
        self.set_expanded(expanded);
        self
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn actual_text(&self) -> Option<&str> {
        self.as_any().actual_text()
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn set_actual_text(&mut self, actual_text: Option<String>) {
        self.as_any_mut().set_actual_text(actual_text);
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn with_actual_text(mut self, actual_text: Option<String>) -> Self {
        self.set_actual_text(actual_text);
        self
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn title(&self) -> Option<&str> {
        self.as_any().title()
    }

    /// The heading level
    pub fn level(&self) -> Option<NonZeroU32> {
        self.as_any().level()
    }

    /// The list numbering.
    pub fn numbering(&self) -> Option<ListNumbering> {
        self.as_any().numbering()
    }

    /// The table summary.
    pub fn summary(&self) -> Option<&str> {
        self.as_any().summary()
    }

    /// The table header scope.
    pub fn scope(&self) -> Option<TableHeaderScope> {
        self.as_any().scope()
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn headers(&self) -> Option<&[TagId]> {
        self.as_any().headers()
    }

    /// The row span of this table cell.
    pub fn row_span(&self) -> Option<NonZeroU32> {
        self.as_any().row_span()
    }

    /// The column span of this table cell.
    pub fn col_span(&self) -> Option<NonZeroU32> {
        self.as_any().col_span()
    }

    /// The placement.
    pub fn placement(&self) -> Option<Placement> {
        self.as_any().placement()
    }

    /// The placement.
    pub fn set_placement(&mut self, placement: Option<Placement>) {
        self.as_any_mut().set_placement(placement);
    }

    /// The placement.
    pub fn with_placement(mut self, placement: Option<Placement>) -> Self {
        self.set_placement(placement);
        self
    }

    /// The writing mode.
    pub fn writing_mode(&self) -> Option<WritingMode> {
        self.as_any().writing_mode()
    }

    /// The writing mode.
    pub fn set_writing_mode(&mut self, writing_mode: Option<WritingMode>) {
        self.as_any_mut().set_writing_mode(writing_mode);
    }

    /// The writing mode.
    pub fn with_writing_mode(mut self, writing_mode: Option<WritingMode>) -> Self {
        self.set_writing_mode(writing_mode);
        self
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.as_any().bbox()
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.as_any().width()
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.as_any().height()
    }
}

// Read accessors for all attributes and write accessors for global ones.
impl AnyTag {
    #[inline(always)]
    fn get_attr<const ORDINAL: usize>(&self) -> Option<&Attr> {
        self.attrs.get::<ORDINAL>().map(AnyAttr::unwrap_attr)
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_attr(&mut self, attr: Attr) {
        self.attrs.set(AnyAttr::Attr(attr));
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_or_remove_attr<const ORDINAL: usize>(&mut self, attr: Option<Attr>) {
        self.attrs.set_or_remove::<ORDINAL>(attr.map(AnyAttr::Attr));
    }

    #[inline(always)]
    fn get_list_attr<const ORDINAL: usize>(&self) -> Option<&ListAttr> {
        self.attrs.get::<ORDINAL>().map(AnyAttr::unwrap_list_attr)
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_list_attr(&mut self, list_attr: ListAttr) {
        self.attrs.set(AnyAttr::ListAttr(list_attr));
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_or_remove_list_attr<const ORDINAL: usize>(&mut self, list_attr: Option<ListAttr>) {
        self.attrs.set_or_remove::<ORDINAL>(list_attr.map(AnyAttr::ListAttr));
    }

    #[inline(always)]
    fn get_table_attr<const ORDINAL: usize>(&self) -> Option<&TableAttr> {
        self.attrs.get::<ORDINAL>().map(AnyAttr::unwrap_table_attr)
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_table_attr(&mut self, table_attr: TableAttr) {
        self.attrs.set(AnyAttr::TableAttr(table_attr));
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_or_remove_table_attr<const ORDINAL: usize>(&mut self, table_attr: Option<TableAttr>) {
        self.attrs.set_or_remove::<ORDINAL>(table_attr.map(AnyAttr::TableAttr));
    }

    #[inline(always)]
    fn get_layout_attr<const ORDINAL: usize>(&self) -> Option<&LayoutAttr> {
        self.attrs.get::<ORDINAL>().map(AnyAttr::unwrap_layout_attr)
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_layout_attr(&mut self, layout_attr: LayoutAttr) {
        self.attrs.set(AnyAttr::LayoutAttr(layout_attr));
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_or_remove_layout_attr<const ORDINAL: usize>(&mut self, layout_attr: Option<LayoutAttr>) {
        self.attrs.set_or_remove::<ORDINAL>(layout_attr.map(AnyAttr::LayoutAttr));
    }


    /// The tag id.
    pub fn id(&self) -> Option<&TagId> {
        self.get_attr::<{Attr::ID}>().map(Attr::unwrap_id)
    }

    /// The tag id.
    pub fn set_id(&mut self, id: Option<TagId>) {
        self.set_or_remove_attr::<{Attr::ID}>(id.map(Attr::Id));
    }

    /// The tag id.
    pub fn with_id(mut self, id: Option<TagId>) -> Self {
        self.set_id(id);
        self
    }

    /// The language of this tag.
    pub fn lang(&self) -> Option<&str> {
        self.get_attr::<{Attr::LANG}>().map(Attr::unwrap_lang)
    }

    /// The language of this tag.
    pub fn set_lang(&mut self, lang: Option<String>) {
        self.set_or_remove_attr::<{Attr::LANG}>(lang.map(Attr::Lang));
    }

    /// The language of this tag.
    pub fn with_lang(mut self, lang: Option<String>) -> Self {
        self.set_lang(lang);
        self
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn alt_text(&self) -> Option<&str> {
        self.get_attr::<{Attr::ALT_TEXT}>().map(Attr::unwrap_alt_text)
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn set_alt_text(&mut self, alt_text: Option<String>) {
        self.set_or_remove_attr::<{Attr::ALT_TEXT}>(alt_text.map(Attr::AltText));
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn with_alt_text(mut self, alt_text: Option<String>) -> Self {
        self.set_alt_text(alt_text);
        self
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn expanded(&self) -> Option<&str> {
        self.get_attr::<{Attr::EXPANDED}>().map(Attr::unwrap_expanded)
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn set_expanded(&mut self, expanded: Option<String>) {
        self.set_or_remove_attr::<{Attr::EXPANDED}>(expanded.map(Attr::Expanded));
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn with_expanded(mut self, expanded: Option<String>) -> Self {
        self.set_expanded(expanded);
        self
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn actual_text(&self) -> Option<&str> {
        self.get_attr::<{Attr::ACTUAL_TEXT}>().map(Attr::unwrap_actual_text)
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn set_actual_text(&mut self, actual_text: Option<String>) {
        self.set_or_remove_attr::<{Attr::ACTUAL_TEXT}>(actual_text.map(Attr::ActualText));
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn with_actual_text(mut self, actual_text: Option<String>) -> Self {
        self.set_actual_text(actual_text);
        self
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn title(&self) -> Option<&str> {
        self.get_attr::<{Attr::TITLE}>().map(Attr::unwrap_title)
    }

    /// The heading level
    pub fn level(&self) -> Option<NonZeroU32> {
        self.get_attr::<{Attr::HEADING_LEVEL}>().map(Attr::unwrap_level)
    }

    /// The list numbering.
    pub fn numbering(&self) -> Option<ListNumbering> {
        self.get_list_attr::<{ListAttr::NUMBERING}>().map(ListAttr::unwrap_numbering)
    }

    /// The table summary.
    pub fn summary(&self) -> Option<&str> {
        self.get_table_attr::<{TableAttr::SUMMARY}>().map(TableAttr::unwrap_summary)
    }

    /// The table header scope.
    pub fn scope(&self) -> Option<TableHeaderScope> {
        self.get_table_attr::<{TableAttr::HEADER_SCOPE}>().map(TableAttr::unwrap_scope)
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn headers(&self) -> Option<&[TagId]> {
        self.get_table_attr::<{TableAttr::CELL_HEADERS}>().map(TableAttr::unwrap_headers)
    }

    /// The row span of this table cell.
    pub fn row_span(&self) -> Option<NonZeroU32> {
        self.get_table_attr::<{TableAttr::ROW_SPAN}>().map(TableAttr::unwrap_row_span)
    }

    /// The column span of this table cell.
    pub fn col_span(&self) -> Option<NonZeroU32> {
        self.get_table_attr::<{TableAttr::COL_SPAN}>().map(TableAttr::unwrap_col_span)
    }

    /// The placement.
    pub fn placement(&self) -> Option<Placement> {
        self.get_layout_attr::<{LayoutAttr::PLACEMENT}>().map(LayoutAttr::unwrap_placement)
    }

    /// The placement.
    pub fn set_placement(&mut self, placement: Option<Placement>) {
        self.set_or_remove_layout_attr::<{LayoutAttr::PLACEMENT}>(placement.map(LayoutAttr::Placement));
    }

    /// The placement.
    pub fn with_placement(mut self, placement: Option<Placement>) -> Self {
        self.set_placement(placement);
        self
    }

    /// The writing mode.
    pub fn writing_mode(&self) -> Option<WritingMode> {
        self.get_layout_attr::<{LayoutAttr::WRITING_MODE}>().map(LayoutAttr::unwrap_writing_mode)
    }

    /// The writing mode.
    pub fn set_writing_mode(&mut self, writing_mode: Option<WritingMode>) {
        self.set_or_remove_layout_attr::<{LayoutAttr::WRITING_MODE}>(writing_mode.map(LayoutAttr::WritingMode));
    }

    /// The writing mode.
    pub fn with_writing_mode(mut self, writing_mode: Option<WritingMode>) -> Self {
        self.set_writing_mode(writing_mode);
        self
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.get_layout_attr::<{LayoutAttr::B_BOX}>().map(LayoutAttr::unwrap_bbox)
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.get_layout_attr::<{LayoutAttr::WIDTH}>().map(LayoutAttr::unwrap_width)
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.get_layout_attr::<{LayoutAttr::HEIGHT}>().map(LayoutAttr::unwrap_height)
    }
}

impl<T> Tag<T> {

    /// The tag id.
    pub fn id(&self) -> Option<&TagId> {
        self.inner.get_attr::<{Attr::ID}>().map(Attr::unwrap_id)
    }

    /// The tag id.
    pub fn set_id(&mut self, id: Option<TagId>) {
        self.inner.set_or_remove_attr::<{Attr::ID}>(id.map(Attr::Id));
    }

    /// The tag id.
    pub fn with_id(mut self, id: Option<TagId>) -> Self {
        self.set_id(id);
        self
    }

    /// The language of this tag.
    pub fn lang(&self) -> Option<&str> {
        self.inner.get_attr::<{Attr::LANG}>().map(Attr::unwrap_lang)
    }

    /// The language of this tag.
    pub fn set_lang(&mut self, lang: Option<String>) {
        self.inner.set_or_remove_attr::<{Attr::LANG}>(lang.map(Attr::Lang));
    }

    /// The language of this tag.
    pub fn with_lang(mut self, lang: Option<String>) -> Self {
        self.set_lang(lang);
        self
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn alt_text(&self) -> Option<&str> {
        self.inner.get_attr::<{Attr::ALT_TEXT}>().map(Attr::unwrap_alt_text)
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn set_alt_text(&mut self, alt_text: Option<String>) {
        self.inner.set_or_remove_attr::<{Attr::ALT_TEXT}>(alt_text.map(Attr::AltText));
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn with_alt_text(mut self, alt_text: Option<String>) -> Self {
        self.set_alt_text(alt_text);
        self
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn expanded(&self) -> Option<&str> {
        self.inner.get_attr::<{Attr::EXPANDED}>().map(Attr::unwrap_expanded)
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn set_expanded(&mut self, expanded: Option<String>) {
        self.inner.set_or_remove_attr::<{Attr::EXPANDED}>(expanded.map(Attr::Expanded));
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn with_expanded(mut self, expanded: Option<String>) -> Self {
        self.set_expanded(expanded);
        self
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn actual_text(&self) -> Option<&str> {
        self.inner.get_attr::<{Attr::ACTUAL_TEXT}>().map(Attr::unwrap_actual_text)
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn set_actual_text(&mut self, actual_text: Option<String>) {
        self.inner.set_or_remove_attr::<{Attr::ACTUAL_TEXT}>(actual_text.map(Attr::ActualText));
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn with_actual_text(mut self, actual_text: Option<String>) -> Self {
        self.set_actual_text(actual_text);
        self
    }

    /// The placement.
    pub fn placement(&self) -> Option<Placement> {
        self.inner.get_layout_attr::<{LayoutAttr::PLACEMENT}>().map(LayoutAttr::unwrap_placement)
    }

    /// The placement.
    pub fn set_placement(&mut self, placement: Option<Placement>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::PLACEMENT}>(placement.map(LayoutAttr::Placement));
    }

    /// The placement.
    pub fn with_placement(mut self, placement: Option<Placement>) -> Self {
        self.set_placement(placement);
        self
    }

    /// The writing mode.
    pub fn writing_mode(&self) -> Option<WritingMode> {
        self.inner.get_layout_attr::<{LayoutAttr::WRITING_MODE}>().map(LayoutAttr::unwrap_writing_mode)
    }

    /// The writing mode.
    pub fn set_writing_mode(&mut self, writing_mode: Option<WritingMode>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::WRITING_MODE}>(writing_mode.map(LayoutAttr::WritingMode));
    }

    /// The writing mode.
    pub fn with_writing_mode(mut self, writing_mode: Option<WritingMode>) -> Self {
        self.set_writing_mode(writing_mode);
        self
    }
}

/// A part of a document that may contain multiple articles or sections.
#[derive(Clone, Debug, PartialEq)]
pub struct Part;

impl From<Tag<Part>> for TagKind {
    fn from(value: Tag<Part>) -> Self {
        Self::Part(value)
    }
}
impl Tag<Part> {
    /// A part of a document that may contain multiple articles or sections.
    #[allow(non_upper_case_globals)]
    pub const Part: Tag<Part> = Tag::new();
}

/// An article with largely self-contained content.
#[derive(Clone, Debug, PartialEq)]
pub struct Article;

impl From<Tag<Article>> for TagKind {
    fn from(value: Tag<Article>) -> Self {
        Self::Article(value)
    }
}
impl Tag<Article> {
    /// An article with largely self-contained content.
    #[allow(non_upper_case_globals)]
    pub const Article: Tag<Article> = Tag::new();
}

/// Section of a larger document.
#[derive(Clone, Debug, PartialEq)]
pub struct Section;

impl From<Tag<Section>> for TagKind {
    fn from(value: Tag<Section>) -> Self {
        Self::Section(value)
    }
}
impl Tag<Section> {
    /// Section of a larger document.
    #[allow(non_upper_case_globals)]
    pub const Section: Tag<Section> = Tag::new();
}

/// A paragraph-level quote.
#[derive(Clone, Debug, PartialEq)]
pub struct BlockQuote;

impl From<Tag<BlockQuote>> for TagKind {
    fn from(value: Tag<BlockQuote>) -> Self {
        Self::BlockQuote(value)
    }
}
impl Tag<BlockQuote> {
    /// A paragraph-level quote.
    #[allow(non_upper_case_globals)]
    pub const BlockQuote: Tag<BlockQuote> = Tag::new();
}

/// An image or figure caption.
///
/// **Best Practice**: In the tag tree, this should appear
/// as a sibling after the image (or other) content it describes.
#[derive(Clone, Debug, PartialEq)]
pub struct Caption;

impl From<Tag<Caption>> for TagKind {
    fn from(value: Tag<Caption>) -> Self {
        Self::Caption(value)
    }
}
impl Tag<Caption> {
    /// An image or figure caption.
    ///
    /// **Best Practice**: In the tag tree, this should appear
    /// as a sibling after the image (or other) content it describes.
    #[allow(non_upper_case_globals)]
    pub const Caption: Tag<Caption> = Tag::new();
}

/// Table of contents.
///
/// **Best Practice**: Should consist of TOCIs or other nested TOCs.
#[derive(Clone, Debug, PartialEq)]
pub struct TOC;

impl From<Tag<TOC>> for TagKind {
    fn from(value: Tag<TOC>) -> Self {
        Self::TOC(value)
    }
}
impl Tag<TOC> {
    /// Table of contents.
    ///
    /// **Best Practice**: Should consist of TOCIs or other nested TOCs.
    #[allow(non_upper_case_globals)]
    pub const TOC: Tag<TOC> = Tag::new();
}

/// Item in the table of contents.
///
/// **Best Practice**: Should only appear within a TOC. Should only consist of
/// labels, references, paragraphs and TOCs.
#[derive(Clone, Debug, PartialEq)]
pub struct TOCI;

impl From<Tag<TOCI>> for TagKind {
    fn from(value: Tag<TOCI>) -> Self {
        Self::TOCI(value)
    }
}
impl Tag<TOCI> {
    /// Item in the table of contents.
    ///
    /// **Best Practice**: Should only appear within a TOC. Should only consist of
    /// labels, references, paragraphs and TOCs.
    #[allow(non_upper_case_globals)]
    pub const TOCI: Tag<TOCI> = Tag::new();
}

/// Index of the key terms in the document.
///
/// **Best Practice**: Should contain a sequence of text accompanied by
/// reference elements pointing to their occurrence in the text.
#[derive(Clone, Debug, PartialEq)]
pub struct Index;

impl From<Tag<Index>> for TagKind {
    fn from(value: Tag<Index>) -> Self {
        Self::Index(value)
    }
}
impl Tag<Index> {
    /// Index of the key terms in the document.
    ///
    /// **Best Practice**: Should contain a sequence of text accompanied by
    /// reference elements pointing to their occurrence in the text.
    #[allow(non_upper_case_globals)]
    pub const Index: Tag<Index> = Tag::new();
}

/// A paragraph.
#[derive(Clone, Debug, PartialEq)]
pub struct P;

impl From<Tag<P>> for TagKind {
    fn from(value: Tag<P>) -> Self {
        Self::P(value)
    }
}
impl Tag<P> {
    /// A paragraph.
    #[allow(non_upper_case_globals)]
    pub const P: Tag<P> = Tag::new();
}

/// Heading level `n`, including an optional title of the heading.
///
/// The title is required for some export modes, like for example PDF/UA.
#[derive(Clone, Debug, PartialEq)]
pub struct Hn;

impl From<Tag<Hn>> for TagKind {
    fn from(value: Tag<Hn>) -> Self {
        Self::Hn(value)
    }
}
impl Tag<Hn> {
    /// Heading level `n`, including an optional title of the heading.
    ///
    /// The title is required for some export modes, like for example PDF/UA.
    #[allow(non_snake_case)]
    pub fn Hn(level: NonZeroU32, title: Option<String>) -> Tag<Hn> {
        let mut tag = Tag::new();
        tag.set_level(level);
        tag.set_title(title);
        tag
    }

    /// The heading level
    pub fn level(&self) -> NonZeroU32 {
        self.inner.get_attr::<{Attr::HEADING_LEVEL}>().unwrap().unwrap_level()
    }

    /// The heading level
    pub fn set_level(&mut self, level: NonZeroU32) {
        self.inner.set_attr(Attr::HeadingLevel(level));
    }

    /// The heading level
    pub fn with_level(mut self, level: NonZeroU32) -> Self {
        self.set_level(level);
        self
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn title(&self) -> Option<&str> {
        self.inner.get_attr::<{Attr::TITLE}>().map(Attr::unwrap_title)
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn set_title(&mut self, title: Option<String>) {
        self.inner.set_or_remove_attr::<{Attr::TITLE}>(title.map(Attr::Title));
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn with_title(mut self, title: Option<String>) -> Self {
        self.set_title(title);
        self
    }
}

/// A list.
///
/// **Best practice**: Should consist of an optional caption followed by
/// list items.
/// List numbering is only required for PDF/UA, but we just enforce it for always.
#[derive(Clone, Debug, PartialEq)]
pub struct L;

impl From<Tag<L>> for TagKind {
    fn from(value: Tag<L>) -> Self {
        Self::L(value)
    }
}
impl Tag<L> {
    /// A list.
    ///
    /// **Best practice**: Should consist of an optional caption followed by
    /// list items.
    /// List numbering is only required for PDF/UA, but we just enforce it for always.
    #[allow(non_snake_case)]
    pub fn L(numbering: ListNumbering) -> Tag<L> {
        let mut tag = Tag::new();
        tag.set_numbering(numbering);
        tag
    }

    /// The list numbering.
    pub fn numbering(&self) -> ListNumbering {
        self.inner.get_list_attr::<{ListAttr::NUMBERING}>().unwrap().unwrap_numbering()
    }

    /// The list numbering.
    pub fn set_numbering(&mut self, numbering: ListNumbering) {
        self.inner.set_list_attr(ListAttr::Numbering(numbering));
    }

    /// The list numbering.
    pub fn with_numbering(mut self, numbering: ListNumbering) -> Self {
        self.set_numbering(numbering);
        self
    }
}

/// A list item.
///
/// **Best practice**: Should consist of one or more list labels and/or list bodies.
#[derive(Clone, Debug, PartialEq)]
pub struct LI;

impl From<Tag<LI>> for TagKind {
    fn from(value: Tag<LI>) -> Self {
        Self::LI(value)
    }
}
impl Tag<LI> {
    /// A list item.
    ///
    /// **Best practice**: Should consist of one or more list labels and/or list bodies.
    #[allow(non_upper_case_globals)]
    pub const LI: Tag<LI> = Tag::new();
}

/// Label for a list item.
#[derive(Clone, Debug, PartialEq)]
pub struct Lbl;

impl From<Tag<Lbl>> for TagKind {
    fn from(value: Tag<Lbl>) -> Self {
        Self::Lbl(value)
    }
}
impl Tag<Lbl> {
    /// Label for a list item.
    #[allow(non_upper_case_globals)]
    pub const Lbl: Tag<Lbl> = Tag::new();
}

/// Description of the list item.
#[derive(Clone, Debug, PartialEq)]
pub struct LBody;

impl From<Tag<LBody>> for TagKind {
    fn from(value: Tag<LBody>) -> Self {
        Self::LBody(value)
    }
}
impl Tag<LBody> {
    /// Description of the list item.
    #[allow(non_upper_case_globals)]
    pub const LBody: Tag<LBody> = Tag::new();
}

/// A table, with an optional summary describing the purpose and structure.
///
/// **Best practice**: Should consist of an optional table header row,
/// one or more table body elements and an optional table footer. Can have
/// caption as the first or last child.
#[derive(Clone, Debug, PartialEq)]
pub struct Table;

impl From<Tag<Table>> for TagKind {
    fn from(value: Tag<Table>) -> Self {
        Self::Table(value)
    }
}
impl Tag<Table> {
    /// A table, with an optional summary describing the purpose and structure.
    ///
    /// **Best practice**: Should consist of an optional table header row,
    /// one or more table body elements and an optional table footer. Can have
    /// caption as the first or last child.
    #[allow(non_upper_case_globals)]
    pub const Table: Tag<Table> = Tag::new();

    /// The table summary.
    pub fn summary(&self) -> Option<&str> {
        self.inner.get_table_attr::<{TableAttr::SUMMARY}>().map(TableAttr::unwrap_summary)
    }

    /// The table summary.
    pub fn set_summary(&mut self, summary: Option<String>) {
        self.inner.set_or_remove_table_attr::<{TableAttr::SUMMARY}>(summary.map(TableAttr::Summary));
    }

    /// The table summary.
    pub fn with_summary(mut self, summary: Option<String>) -> Self {
        self.set_summary(summary);
        self
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.inner.get_layout_attr::<{LayoutAttr::B_BOX}>().map(LayoutAttr::unwrap_bbox)
    }

    /// The bounding box.
    pub fn set_bbox(&mut self, bbox: Option<Rect>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::B_BOX}>(bbox.map(LayoutAttr::BBox));
    }

    /// The bounding box.
    pub fn with_bbox(mut self, bbox: Option<Rect>) -> Self {
        self.set_bbox(bbox);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::WIDTH}>().map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::WIDTH}>(width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::HEIGHT}>().map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::HEIGHT}>(height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

/// A table row.
///
/// **Best practice**: May contain table headers cells and table data cells.
#[derive(Clone, Debug, PartialEq)]
pub struct TR;

impl From<Tag<TR>> for TagKind {
    fn from(value: Tag<TR>) -> Self {
        Self::TR(value)
    }
}
impl Tag<TR> {
    /// A table row.
    ///
    /// **Best practice**: May contain table headers cells and table data cells.
    #[allow(non_upper_case_globals)]
    pub const TR: Tag<TR> = Tag::new();
}

/// A table header cell.
#[derive(Clone, Debug, PartialEq)]
pub struct TH;

impl From<Tag<TH>> for TagKind {
    fn from(value: Tag<TH>) -> Self {
        Self::TH(value)
    }
}
impl Tag<TH> {
    /// A table header cell.
    #[allow(non_snake_case)]
    pub fn TH(scope: TableHeaderScope) -> Tag<TH> {
        let mut tag = Tag::new();
        tag.set_scope(scope);
        tag
    }

    /// The table header scope.
    pub fn scope(&self) -> TableHeaderScope {
        self.inner.get_table_attr::<{TableAttr::HEADER_SCOPE}>().unwrap().unwrap_scope()
    }

    /// The table header scope.
    pub fn set_scope(&mut self, scope: TableHeaderScope) {
        self.inner.set_table_attr(TableAttr::HeaderScope(scope));
    }

    /// The table header scope.
    pub fn with_scope(mut self, scope: TableHeaderScope) -> Self {
        self.set_scope(scope);
        self
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn headers(&self) -> Option<&[TagId]> {
        self.inner.get_table_attr::<{TableAttr::CELL_HEADERS}>().map(TableAttr::unwrap_headers)
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn set_headers(&mut self, headers: impl IntoIterator<Item = TagId>) {
        self.inner.set_table_attr(TableAttr::CellHeaders(headers.into_iter().collect()));
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn with_headers(mut self, headers: impl IntoIterator<Item = TagId>) -> Self {
        self.set_headers(headers);
        self
    }

    /// The row span of this table cell.
    pub fn row_span(&self) -> Option<NonZeroU32> {
        self.inner.get_table_attr::<{TableAttr::ROW_SPAN}>().map(TableAttr::unwrap_row_span)
    }

    /// The row span of this table cell.
    pub fn set_row_span(&mut self, row_span: Option<NonZeroU32>) {
        self.inner.set_or_remove_table_attr::<{TableAttr::ROW_SPAN}>(row_span.map(TableAttr::RowSpan));
    }

    /// The row span of this table cell.
    pub fn with_row_span(mut self, row_span: Option<NonZeroU32>) -> Self {
        self.set_row_span(row_span);
        self
    }

    /// The column span of this table cell.
    pub fn col_span(&self) -> Option<NonZeroU32> {
        self.inner.get_table_attr::<{TableAttr::COL_SPAN}>().map(TableAttr::unwrap_col_span)
    }

    /// The column span of this table cell.
    pub fn set_col_span(&mut self, col_span: Option<NonZeroU32>) {
        self.inner.set_or_remove_table_attr::<{TableAttr::COL_SPAN}>(col_span.map(TableAttr::ColSpan));
    }

    /// The column span of this table cell.
    pub fn with_col_span(mut self, col_span: Option<NonZeroU32>) -> Self {
        self.set_col_span(col_span);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::WIDTH}>().map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::WIDTH}>(width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::HEIGHT}>().map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::HEIGHT}>(height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

/// A table data cell.
#[derive(Clone, Debug, PartialEq)]
pub struct TD;

impl From<Tag<TD>> for TagKind {
    fn from(value: Tag<TD>) -> Self {
        Self::TD(value)
    }
}
impl Tag<TD> {
    /// A table data cell.
    #[allow(non_upper_case_globals)]
    pub const TD: Tag<TD> = Tag::new();

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn headers(&self) -> Option<&[TagId]> {
        self.inner.get_table_attr::<{TableAttr::CELL_HEADERS}>().map(TableAttr::unwrap_headers)
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn set_headers(&mut self, headers: impl IntoIterator<Item = TagId>) {
        self.inner.set_table_attr(TableAttr::CellHeaders(headers.into_iter().collect()));
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn with_headers(mut self, headers: impl IntoIterator<Item = TagId>) -> Self {
        self.set_headers(headers);
        self
    }

    /// The row span of this table cell.
    pub fn row_span(&self) -> Option<NonZeroU32> {
        self.inner.get_table_attr::<{TableAttr::ROW_SPAN}>().map(TableAttr::unwrap_row_span)
    }

    /// The row span of this table cell.
    pub fn set_row_span(&mut self, row_span: Option<NonZeroU32>) {
        self.inner.set_or_remove_table_attr::<{TableAttr::ROW_SPAN}>(row_span.map(TableAttr::RowSpan));
    }

    /// The row span of this table cell.
    pub fn with_row_span(mut self, row_span: Option<NonZeroU32>) -> Self {
        self.set_row_span(row_span);
        self
    }

    /// The column span of this table cell.
    pub fn col_span(&self) -> Option<NonZeroU32> {
        self.inner.get_table_attr::<{TableAttr::COL_SPAN}>().map(TableAttr::unwrap_col_span)
    }

    /// The column span of this table cell.
    pub fn set_col_span(&mut self, col_span: Option<NonZeroU32>) {
        self.inner.set_or_remove_table_attr::<{TableAttr::COL_SPAN}>(col_span.map(TableAttr::ColSpan));
    }

    /// The column span of this table cell.
    pub fn with_col_span(mut self, col_span: Option<NonZeroU32>) -> Self {
        self.set_col_span(col_span);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::WIDTH}>().map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::WIDTH}>(width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::HEIGHT}>().map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::HEIGHT}>(height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

/// A table header row group.
#[derive(Clone, Debug, PartialEq)]
pub struct THead;

impl From<Tag<THead>> for TagKind {
    fn from(value: Tag<THead>) -> Self {
        Self::THead(value)
    }
}
impl Tag<THead> {
    /// A table header row group.
    #[allow(non_upper_case_globals)]
    pub const THead: Tag<THead> = Tag::new();
}

/// A table data row group.
#[derive(Clone, Debug, PartialEq)]
pub struct TBody;

impl From<Tag<TBody>> for TagKind {
    fn from(value: Tag<TBody>) -> Self {
        Self::TBody(value)
    }
}
impl Tag<TBody> {
    /// A table data row group.
    #[allow(non_upper_case_globals)]
    pub const TBody: Tag<TBody> = Tag::new();
}

/// A table footer row group.
#[derive(Clone, Debug, PartialEq)]
pub struct TFoot;

impl From<Tag<TFoot>> for TagKind {
    fn from(value: Tag<TFoot>) -> Self {
        Self::TFoot(value)
    }
}
impl Tag<TFoot> {
    /// A table footer row group.
    #[allow(non_upper_case_globals)]
    pub const TFoot: Tag<TFoot> = Tag::new();
}

/// An inline quotation.
#[derive(Clone, Debug, PartialEq)]
pub struct InlineQuote;

impl From<Tag<InlineQuote>> for TagKind {
    fn from(value: Tag<InlineQuote>) -> Self {
        Self::InlineQuote(value)
    }
}
impl Tag<InlineQuote> {
    /// An inline quotation.
    #[allow(non_upper_case_globals)]
    pub const InlineQuote: Tag<InlineQuote> = Tag::new();
}

/// A foot- or endnote, potentially referred to from within the text.
///
/// **Best practice**: It may have a label as a child.
#[derive(Clone, Debug, PartialEq)]
pub struct Note;

impl From<Tag<Note>> for TagKind {
    fn from(value: Tag<Note>) -> Self {
        Self::Note(value)
    }
}
impl Tag<Note> {
    /// A foot- or endnote, potentially referred to from within the text.
    ///
    /// **Best practice**: It may have a label as a child.
    #[allow(non_upper_case_globals)]
    pub const Note: Tag<Note> = Tag::new();
}

/// A reference to elsewhere in the document.
///
/// **Best practice**: The first child of a tag group with this tag should be a link annotation
/// linking to a destination in the document, and the second child should consist of
/// the children that should be associated with that reference.
#[derive(Clone, Debug, PartialEq)]
pub struct Reference;

impl From<Tag<Reference>> for TagKind {
    fn from(value: Tag<Reference>) -> Self {
        Self::Reference(value)
    }
}
impl Tag<Reference> {
    /// A reference to elsewhere in the document.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to a destination in the document, and the second child should consist of
    /// the children that should be associated with that reference.
    #[allow(non_upper_case_globals)]
    pub const Reference: Tag<Reference> = Tag::new();
}

/// A reference to the external source of some cited document.
///
/// **Best practice**: It may have a label as a child.
#[derive(Clone, Debug, PartialEq)]
pub struct BibEntry;

impl From<Tag<BibEntry>> for TagKind {
    fn from(value: Tag<BibEntry>) -> Self {
        Self::BibEntry(value)
    }
}
impl Tag<BibEntry> {
    /// A reference to the external source of some cited document.
    ///
    /// **Best practice**: It may have a label as a child.
    #[allow(non_upper_case_globals)]
    pub const BibEntry: Tag<BibEntry> = Tag::new();
}

/// Computer code.
#[derive(Clone, Debug, PartialEq)]
pub struct Code;

impl From<Tag<Code>> for TagKind {
    fn from(value: Tag<Code>) -> Self {
        Self::Code(value)
    }
}
impl Tag<Code> {
    /// Computer code.
    #[allow(non_upper_case_globals)]
    pub const Code: Tag<Code> = Tag::new();
}

/// A link.
///
/// **Best practice**: The first child of a tag group with this tag should be a link annotation
/// linking to an URL, and the second child should consist of the children that should
/// be associated with that link.
#[derive(Clone, Debug, PartialEq)]
pub struct Link;

impl From<Tag<Link>> for TagKind {
    fn from(value: Tag<Link>) -> Self {
        Self::Link(value)
    }
}
impl Tag<Link> {
    /// A link.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to an URL, and the second child should consist of the children that should
    /// be associated with that link.
    #[allow(non_upper_case_globals)]
    pub const Link: Tag<Link> = Tag::new();
}

/// An association between an annotation and the content it belongs to. PDF
///
/// **Best practice**: Should be used for all annotations, except for link annotations and
/// widget annotations. The first child should be the identifier of a non-link annotation,
/// and all other subsequent children should be content identifiers associated with that
/// annotation.
#[derive(Clone, Debug, PartialEq)]
pub struct Annot;

impl From<Tag<Annot>> for TagKind {
    fn from(value: Tag<Annot>) -> Self {
        Self::Annot(value)
    }
}
impl Tag<Annot> {
    /// An association between an annotation and the content it belongs to. PDF
    ///
    /// **Best practice**: Should be used for all annotations, except for link annotations and
    /// widget annotations. The first child should be the identifier of a non-link annotation,
    /// and all other subsequent children should be content identifiers associated with that
    /// annotation.
    #[allow(non_upper_case_globals)]
    pub const Annot: Tag<Annot> = Tag::new();
}

/// Item of graphical content.
///
/// Providing [`Tag::alt_text`] is required in some export modes, like for example PDF/UA1.
#[derive(Clone, Debug, PartialEq)]
pub struct Figure;

impl From<Tag<Figure>> for TagKind {
    fn from(value: Tag<Figure>) -> Self {
        Self::Figure(value)
    }
}
impl Tag<Figure> {
    /// Item of graphical content.
    ///
    /// Providing [`Tag::alt_text`] is required in some export modes, like for example PDF/UA1.
    #[allow(non_snake_case)]
    pub fn Figure(alt_text: Option<String>) -> Tag<Figure> {
        let mut tag = Tag::new();
        tag.set_alt_text(alt_text);
        tag
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.inner.get_layout_attr::<{LayoutAttr::B_BOX}>().map(LayoutAttr::unwrap_bbox)
    }

    /// The bounding box.
    pub fn set_bbox(&mut self, bbox: Option<Rect>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::B_BOX}>(bbox.map(LayoutAttr::BBox));
    }

    /// The bounding box.
    pub fn with_bbox(mut self, bbox: Option<Rect>) -> Self {
        self.set_bbox(bbox);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::WIDTH}>().map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::WIDTH}>(width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::HEIGHT}>().map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::HEIGHT}>(height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

/// A mathematical formula.
///
/// Providing [`Tag::alt_text`] is required in some export modes, like for example PDF/UA1.
#[derive(Clone, Debug, PartialEq)]
pub struct Formula;

impl From<Tag<Formula>> for TagKind {
    fn from(value: Tag<Formula>) -> Self {
        Self::Formula(value)
    }
}
impl Tag<Formula> {
    /// A mathematical formula.
    ///
    /// Providing [`Tag::alt_text`] is required in some export modes, like for example PDF/UA1.
    #[allow(non_snake_case)]
    pub fn Formula(alt_text: Option<String>) -> Tag<Formula> {
        let mut tag = Tag::new();
        tag.set_alt_text(alt_text);
        tag
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.inner.get_layout_attr::<{LayoutAttr::B_BOX}>().map(LayoutAttr::unwrap_bbox)
    }

    /// The bounding box.
    pub fn set_bbox(&mut self, bbox: Option<Rect>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::B_BOX}>(bbox.map(LayoutAttr::BBox));
    }

    /// The bounding box.
    pub fn with_bbox(mut self, bbox: Option<Rect>) -> Self {
        self.set_bbox(bbox);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::WIDTH}>().map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::WIDTH}>(width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout_attr::<{LayoutAttr::HEIGHT}>().map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout_attr::<{LayoutAttr::HEIGHT}>(height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

/// A date or time.
#[derive(Clone, Debug, PartialEq)]
pub struct Datetime;

impl From<Tag<Datetime>> for TagKind {
    fn from(value: Tag<Datetime>) -> Self {
        Self::Datetime(value)
    }
}
impl Tag<Datetime> {
    /// A date or time.
    #[allow(non_upper_case_globals)]
    pub const Datetime: Tag<Datetime> = Tag::new();
}

/// A list of terms.
#[derive(Clone, Debug, PartialEq)]
pub struct Terms;

impl From<Tag<Terms>> for TagKind {
    fn from(value: Tag<Terms>) -> Self {
        Self::Terms(value)
    }
}
impl Tag<Terms> {
    /// A list of terms.
    #[allow(non_upper_case_globals)]
    pub const Terms: Tag<Terms> = Tag::new();
}

/// A title.
#[derive(Clone, Debug, PartialEq)]
pub struct Title;

impl From<Tag<Title>> for TagKind {
    fn from(value: Tag<Title>) -> Self {
        Self::Title(value)
    }
}
impl Tag<Title> {
    /// A title.
    #[allow(non_upper_case_globals)]
    pub const Title: Tag<Title> = Tag::new();
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum AnyAttr {
    Attr(Attr),
    ListAttr(ListAttr),
    TableAttr(TableAttr),
    LayoutAttr(LayoutAttr),
}

impl AnyAttr {

        #[inline(always)]
        fn unwrap_attr(&self) -> &Attr {
            match self {
                Self::Attr(attr) => attr,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_list_attr(&self) -> &ListAttr {
            match self {
                Self::ListAttr(attr) => attr,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_table_attr(&self) -> &TableAttr {
            match self {
                Self::TableAttr(attr) => attr,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_layout_attr(&self) -> &LayoutAttr {
            match self {
                Self::LayoutAttr(attr) => attr,
                _ => unreachable!(),
            }
        }
}
impl Ordinal for AnyAttr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Attr(a) => a.ordinal(),
            Self::ListAttr(a) => a.ordinal(),
            Self::TableAttr(a) => a.ordinal(),
            Self::LayoutAttr(a) => a.ordinal(),
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum Attr {
    /// The tag id.
    Id(TagId),
    /// The language of this tag.
    Lang(String),
    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    AltText(String),
    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    Expanded(String),
    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    ActualText(String),
    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    Title(String),
    /// The heading level
    HeadingLevel(NonZeroU32),
}

impl Attr {
    pub(crate) const ID: usize = 0;
    pub(crate) const LANG: usize = 1;
    pub(crate) const ALT_TEXT: usize = 2;
    pub(crate) const EXPANDED: usize = 3;
    pub(crate) const ACTUAL_TEXT: usize = 4;
    pub(crate) const TITLE: usize = 5;
    pub(crate) const HEADING_LEVEL: usize = 6;

        #[inline(always)]
        fn unwrap_id(&self) -> &TagId {
            match self {
                Self::Id(val) => val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_lang(&self) -> &str {
            match self {
                Self::Lang(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_alt_text(&self) -> &str {
            match self {
                Self::AltText(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_expanded(&self) -> &str {
            match self {
                Self::Expanded(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_actual_text(&self) -> &str {
            match self {
                Self::ActualText(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_title(&self) -> &str {
            match self {
                Self::Title(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_level(&self) -> NonZeroU32 {
            match self {
                Self::HeadingLevel(val) => *val,
                _ => unreachable!(),
            }
        }
}

impl Ordinal for Attr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Id(_) => Self::ID,
            Self::Lang(_) => Self::LANG,
            Self::AltText(_) => Self::ALT_TEXT,
            Self::Expanded(_) => Self::EXPANDED,
            Self::ActualText(_) => Self::ACTUAL_TEXT,
            Self::Title(_) => Self::TITLE,
            Self::HeadingLevel(_) => Self::HEADING_LEVEL,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum ListAttr {
    /// The list numbering.
    Numbering(ListNumbering),
}

impl ListAttr {
    pub(crate) const NUMBERING: usize = 7;

        #[inline(always)]
        fn unwrap_numbering(&self) -> ListNumbering {
            match self {
                Self::Numbering(val) => *val,
            }
        }
}

impl Ordinal for ListAttr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Numbering(_) => Self::NUMBERING,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum TableAttr {
    /// The table summary.
    Summary(String),
    /// The table header scope.
    HeaderScope(TableHeaderScope),
    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    CellHeaders(SmallVec<[TagId; 1]>),
    /// The row span of this table cell.
    RowSpan(NonZeroU32),
    /// The column span of this table cell.
    ColSpan(NonZeroU32),
}

impl TableAttr {
    pub(crate) const SUMMARY: usize = 8;
    pub(crate) const HEADER_SCOPE: usize = 9;
    pub(crate) const CELL_HEADERS: usize = 10;
    pub(crate) const ROW_SPAN: usize = 11;
    pub(crate) const COL_SPAN: usize = 12;

        #[inline(always)]
        fn unwrap_summary(&self) -> &str {
            match self {
                Self::Summary(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_scope(&self) -> TableHeaderScope {
            match self {
                Self::HeaderScope(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_headers(&self) -> &[TagId] {
            match self {
                Self::CellHeaders(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_row_span(&self) -> NonZeroU32 {
            match self {
                Self::RowSpan(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_col_span(&self) -> NonZeroU32 {
            match self {
                Self::ColSpan(val) => *val,
                _ => unreachable!(),
            }
        }
}

impl Ordinal for TableAttr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Summary(_) => Self::SUMMARY,
            Self::HeaderScope(_) => Self::HEADER_SCOPE,
            Self::CellHeaders(_) => Self::CELL_HEADERS,
            Self::RowSpan(_) => Self::ROW_SPAN,
            Self::ColSpan(_) => Self::COL_SPAN,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum LayoutAttr {
    /// The placement.
    Placement(Placement),
    /// The writing mode.
    WritingMode(WritingMode),
    /// The bounding box.
    BBox(Rect),
    /// The width.
    Width(f32),
    /// The height.
    Height(f32),
}

impl LayoutAttr {
    pub(crate) const PLACEMENT: usize = 13;
    pub(crate) const WRITING_MODE: usize = 14;
    pub(crate) const B_BOX: usize = 15;
    pub(crate) const WIDTH: usize = 16;
    pub(crate) const HEIGHT: usize = 17;

        #[inline(always)]
        fn unwrap_placement(&self) -> Placement {
            match self {
                Self::Placement(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_writing_mode(&self) -> WritingMode {
            match self {
                Self::WritingMode(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_bbox(&self) -> Rect {
            match self {
                Self::BBox(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_width(&self) -> f32 {
            match self {
                Self::Width(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_height(&self) -> f32 {
            match self {
                Self::Height(val) => *val,
                _ => unreachable!(),
            }
        }
}

impl Ordinal for LayoutAttr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Placement(_) => Self::PLACEMENT,
            Self::WritingMode(_) => Self::WRITING_MODE,
            Self::BBox(_) => Self::B_BOX,
            Self::Width(_) => Self::WIDTH,
            Self::Height(_) => Self::HEIGHT,
        }
    }
}

