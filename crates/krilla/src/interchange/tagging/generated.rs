// This file is automatically generated!
//
// To update it:
// 1. Edit the `generate.toml` file inside of this directory
// 2. Run `cargo run --bin=codegen` from the repository root

/// A tag for group nodes.
#[derive(Clone, Debug, PartialEq)]
pub enum TagKind {
    /// A part of a document that may contain multiple articles or sections.
    Part(Tag<kind::Part>),
    /// An article with largely self-contained content.
    Article(Tag<kind::Article>),
    /// Section of a larger document.
    Section(Tag<kind::Section>),
    /// A paragraph-level quote.
    BlockQuote(Tag<kind::BlockQuote>),
    /// An image or figure caption.
    ///
    /// **Best Practice**: In the tag tree, this should appear
    /// as a sibling after the image (or other) content it describes.
    Caption(Tag<kind::Caption>),
    /// Table of contents.
    ///
    /// **Best Practice**: Should consist of TOCIs or other nested TOCs.
    TOC(Tag<kind::TOC>),
    /// Item in the table of contents.
    ///
    /// **Best Practice**: Should only appear within a TOC. Should only consist of
    /// labels, references, paragraphs and TOCs.
    TOCI(Tag<kind::TOCI>),
    /// Index of the key terms in the document.
    ///
    /// **Best Practice**: Should contain a sequence of text accompanied by
    /// reference elements pointing to their occurrence in the text.
    Index(Tag<kind::Index>),
    /// A paragraph.
    P(Tag<kind::P>),
    /// Heading level `n`, including an optional title of the heading.
    ///
    /// The title is required for some export modes, like for example PDF/UA.
    Hn(Tag<kind::Hn>),
    /// A list.
    ///
    /// **Best practice**: Should consist of an optional caption followed by
    /// list items.
    /// List numbering is only required for PDF/UA, but we just enforce it for always.
    L(Tag<kind::L>),
    /// A list item.
    ///
    /// **Best practice**: Should consist of one or more list labels and/or list bodies.
    LI(Tag<kind::LI>),
    /// Label for a list item.
    Lbl(Tag<kind::Lbl>),
    /// Description of the list item.
    LBody(Tag<kind::LBody>),
    /// A table, with an optional summary describing the purpose and structure.
    ///
    /// **Best practice**: Should consist of an optional table header row,
    /// one or more table body elements and an optional table footer. Can have
    /// caption as the first or last child.
    Table(Tag<kind::Table>),
    /// A table row.
    ///
    /// **Best practice**: May contain table headers cells and table data cells.
    TR(Tag<kind::TR>),
    /// A table header cell.
    TH(Tag<kind::TH>),
    /// A table data cell.
    TD(Tag<kind::TD>),
    /// A table header row group.
    THead(Tag<kind::THead>),
    /// A table data row group.
    TBody(Tag<kind::TBody>),
    /// A table footer row group.
    TFoot(Tag<kind::TFoot>),
    /// An inline quotation.
    InlineQuote(Tag<kind::InlineQuote>),
    /// A foot- or endnote, potentially referred to from within the text.
    ///
    /// **Best practice**: It may have a label as a child.
    Note(Tag<kind::Note>),
    /// A reference to elsewhere in the document.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to a destination in the document, and the second child should consist of
    /// the children that should be associated with that reference.
    Reference(Tag<kind::Reference>),
    /// A reference to the external source of some cited document.
    ///
    /// **Best practice**: It may have a label as a child.
    BibEntry(Tag<kind::BibEntry>),
    /// Computer code.
    Code(Tag<kind::Code>),
    /// A link.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to an URL, and the second child should consist of the children that should
    /// be associated with that link.
    Link(Tag<kind::Link>),
    /// An association between an annotation and the content it belongs to. PDF
    ///
    /// **Best practice**: Should be used for all annotations, except for link annotations and
    /// widget annotations. The first child should be the identifier of a non-link annotation,
    /// and all other subsequent children should be content identifiers associated with that
    /// annotation.
    Annot(Tag<kind::Annot>),
    /// Item of graphical content.
    ///
    /// Providing `alt_text` is required in some export modes, like for example PDF/UA1.
    Figure(Tag<kind::Figure>),
    /// A mathematical formula.
    ///
    /// Providing `alt_text` is required in some export modes, like for example PDF/UA1.
    Formula(Tag<kind::Formula>),
    /// A date or time.
    Datetime(Tag<kind::Datetime>),
    /// A list of terms.
    Terms(Tag<kind::Terms>),
    /// A title.
    Title(Tag<kind::Title>),
}

impl TagKind {
    /// A type erased tag, which allows reading all attributes.
    pub fn as_any(&self) -> &AnyTag {
        match self {
            Self::Part(tag) => tag.as_any(),
            Self::Article(tag) => tag.as_any(),
            Self::Section(tag) => tag.as_any(),
            Self::BlockQuote(tag) => tag.as_any(),
            Self::Caption(tag) => tag.as_any(),
            Self::TOC(tag) => tag.as_any(),
            Self::TOCI(tag) => tag.as_any(),
            Self::Index(tag) => tag.as_any(),
            Self::P(tag) => tag.as_any(),
            Self::Hn(tag) => tag.as_any(),
            Self::L(tag) => tag.as_any(),
            Self::LI(tag) => tag.as_any(),
            Self::Lbl(tag) => tag.as_any(),
            Self::LBody(tag) => tag.as_any(),
            Self::Table(tag) => tag.as_any(),
            Self::TR(tag) => tag.as_any(),
            Self::TH(tag) => tag.as_any(),
            Self::TD(tag) => tag.as_any(),
            Self::THead(tag) => tag.as_any(),
            Self::TBody(tag) => tag.as_any(),
            Self::TFoot(tag) => tag.as_any(),
            Self::InlineQuote(tag) => tag.as_any(),
            Self::Note(tag) => tag.as_any(),
            Self::Reference(tag) => tag.as_any(),
            Self::BibEntry(tag) => tag.as_any(),
            Self::Code(tag) => tag.as_any(),
            Self::Link(tag) => tag.as_any(),
            Self::Annot(tag) => tag.as_any(),
            Self::Figure(tag) => tag.as_any(),
            Self::Formula(tag) => tag.as_any(),
            Self::Datetime(tag) => tag.as_any(),
            Self::Terms(tag) => tag.as_any(),
            Self::Title(tag) => tag.as_any(),
        }
    }

    /// A type erased tag, which allows reading all attributes and additionally
    /// writing all global attributes.
    pub fn as_any_mut(&mut self) -> &mut AnyTag {
        match self {
            Self::Part(tag) => tag.as_any_mut(),
            Self::Article(tag) => tag.as_any_mut(),
            Self::Section(tag) => tag.as_any_mut(),
            Self::BlockQuote(tag) => tag.as_any_mut(),
            Self::Caption(tag) => tag.as_any_mut(),
            Self::TOC(tag) => tag.as_any_mut(),
            Self::TOCI(tag) => tag.as_any_mut(),
            Self::Index(tag) => tag.as_any_mut(),
            Self::P(tag) => tag.as_any_mut(),
            Self::Hn(tag) => tag.as_any_mut(),
            Self::L(tag) => tag.as_any_mut(),
            Self::LI(tag) => tag.as_any_mut(),
            Self::Lbl(tag) => tag.as_any_mut(),
            Self::LBody(tag) => tag.as_any_mut(),
            Self::Table(tag) => tag.as_any_mut(),
            Self::TR(tag) => tag.as_any_mut(),
            Self::TH(tag) => tag.as_any_mut(),
            Self::TD(tag) => tag.as_any_mut(),
            Self::THead(tag) => tag.as_any_mut(),
            Self::TBody(tag) => tag.as_any_mut(),
            Self::TFoot(tag) => tag.as_any_mut(),
            Self::InlineQuote(tag) => tag.as_any_mut(),
            Self::Note(tag) => tag.as_any_mut(),
            Self::Reference(tag) => tag.as_any_mut(),
            Self::BibEntry(tag) => tag.as_any_mut(),
            Self::Code(tag) => tag.as_any_mut(),
            Self::Link(tag) => tag.as_any_mut(),
            Self::Annot(tag) => tag.as_any_mut(),
            Self::Figure(tag) => tag.as_any_mut(),
            Self::Formula(tag) => tag.as_any_mut(),
            Self::Datetime(tag) => tag.as_any_mut(),
            Self::Terms(tag) => tag.as_any_mut(),
            Self::Title(tag) => tag.as_any_mut(),
        }
    }

    /// The tag id.
    pub fn id(&self) -> Option<&TagId> {
        self.as_any().id()
    }

    /// The tag id.
    pub fn set_id(&mut self, id: Option<TagId>) {
        self.as_any_mut().set_id(id);
    }

    /// The tag id.
    pub fn with_id(mut self, id: Option<TagId>) -> Self {
        self.set_id(id);
        self
    }

    /// The language of this tag.
    pub fn lang(&self) -> Option<&str> {
        self.as_any().lang()
    }

    /// The language of this tag.
    pub fn set_lang(&mut self, lang: Option<String>) {
        self.as_any_mut().set_lang(lang);
    }

    /// The language of this tag.
    pub fn with_lang(mut self, lang: Option<String>) -> Self {
        self.set_lang(lang);
        self
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn alt_text(&self) -> Option<&str> {
        self.as_any().alt_text()
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn set_alt_text(&mut self, alt_text: Option<String>) {
        self.as_any_mut().set_alt_text(alt_text);
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn with_alt_text(mut self, alt_text: Option<String>) -> Self {
        self.set_alt_text(alt_text);
        self
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn expanded(&self) -> Option<&str> {
        self.as_any().expanded()
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn set_expanded(&mut self, expanded: Option<String>) {
        self.as_any_mut().set_expanded(expanded);
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn with_expanded(mut self, expanded: Option<String>) -> Self {
        self.set_expanded(expanded);
        self
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn actual_text(&self) -> Option<&str> {
        self.as_any().actual_text()
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn set_actual_text(&mut self, actual_text: Option<String>) {
        self.as_any_mut().set_actual_text(actual_text);
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn with_actual_text(mut self, actual_text: Option<String>) -> Self {
        self.set_actual_text(actual_text);
        self
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn title(&self) -> Option<&str> {
        self.as_any().title()
    }

    /// The heading level
    pub fn level(&self) -> Option<NonZeroU32> {
        self.as_any().level()
    }

    /// The list numbering.
    pub fn numbering(&self) -> Option<ListNumbering> {
        self.as_any().numbering()
    }

    /// The table summary.
    pub fn summary(&self) -> Option<&str> {
        self.as_any().summary()
    }

    /// The table header scope.
    pub fn scope(&self) -> Option<TableHeaderScope> {
        self.as_any().scope()
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn headers(&self) -> Option<&[TagId]> {
        self.as_any().headers()
    }

    /// The row span of this table cell.
    pub fn row_span(&self) -> Option<NonZeroU32> {
        self.as_any().row_span()
    }

    /// The column span of this table cell.
    pub fn col_span(&self) -> Option<NonZeroU32> {
        self.as_any().col_span()
    }

    /// The placement.
    pub fn placement(&self) -> Option<Placement> {
        self.as_any().placement()
    }

    /// The placement.
    pub fn set_placement(&mut self, placement: Option<Placement>) {
        self.as_any_mut().set_placement(placement);
    }

    /// The placement.
    pub fn with_placement(mut self, placement: Option<Placement>) -> Self {
        self.set_placement(placement);
        self
    }

    /// The writing mode.
    pub fn writing_mode(&self) -> Option<WritingMode> {
        self.as_any().writing_mode()
    }

    /// The writing mode.
    pub fn set_writing_mode(&mut self, writing_mode: Option<WritingMode>) {
        self.as_any_mut().set_writing_mode(writing_mode);
    }

    /// The writing mode.
    pub fn with_writing_mode(mut self, writing_mode: Option<WritingMode>) -> Self {
        self.set_writing_mode(writing_mode);
        self
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.as_any().bbox()
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.as_any().width()
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.as_any().height()
    }
}

// Read accessors for all attributes and write accessors for global ones.
impl AnyTag {
    #[inline(always)]
    fn get_struct(&self, ordinal: usize) -> Option<&StructAttr> {
        self.attrs.get(ordinal).map(Attr::unwrap_struct)
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_struct(&mut self, attr: StructAttr) {
        self.attrs.set(Attr::Struct(attr));
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_or_remove_struct(&mut self, ordinal: usize, attr: Option<StructAttr>) {
        self.attrs.set_or_remove(ordinal, attr.map(Attr::Struct));
    }

    #[inline(always)]
    fn get_list(&self, ordinal: usize) -> Option<&ListAttr> {
        self.attrs.get(ordinal).map(Attr::unwrap_list)
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_list(&mut self, attr: ListAttr) {
        self.attrs.set(Attr::List(attr));
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_or_remove_list(&mut self, ordinal: usize, attr: Option<ListAttr>) {
        self.attrs.set_or_remove(ordinal, attr.map(Attr::List));
    }

    #[inline(always)]
    fn get_table(&self, ordinal: usize) -> Option<&TableAttr> {
        self.attrs.get(ordinal).map(Attr::unwrap_table)
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_table(&mut self, attr: TableAttr) {
        self.attrs.set(Attr::Table(attr));
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_or_remove_table(&mut self, ordinal: usize, attr: Option<TableAttr>) {
        self.attrs.set_or_remove(ordinal, attr.map(Attr::Table));
    }

    #[inline(always)]
    fn get_layout(&self, ordinal: usize) -> Option<&LayoutAttr> {
        self.attrs.get(ordinal).map(Attr::unwrap_layout)
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_layout(&mut self, attr: LayoutAttr) {
        self.attrs.set(Attr::Layout(attr));
    }

    #[allow(unused)]
    #[inline(always)]
    fn set_or_remove_layout(&mut self, ordinal: usize, attr: Option<LayoutAttr>) {
        self.attrs.set_or_remove(ordinal, attr.map(Attr::Layout));
    }


    /// The tag id.
    pub fn id(&self) -> Option<&TagId> {
        self.get_struct(StructAttr::ID).map(StructAttr::unwrap_id)
    }

    /// The tag id.
    pub fn set_id(&mut self, id: Option<TagId>) {
        self.set_or_remove_struct(StructAttr::ID, id.map(StructAttr::Id));
    }

    /// The tag id.
    pub fn with_id(mut self, id: Option<TagId>) -> Self {
        self.set_id(id);
        self
    }

    /// The language of this tag.
    pub fn lang(&self) -> Option<&str> {
        self.get_struct(StructAttr::LANG).map(StructAttr::unwrap_lang)
    }

    /// The language of this tag.
    pub fn set_lang(&mut self, lang: Option<String>) {
        self.set_or_remove_struct(StructAttr::LANG, lang.map(StructAttr::Lang));
    }

    /// The language of this tag.
    pub fn with_lang(mut self, lang: Option<String>) -> Self {
        self.set_lang(lang);
        self
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn alt_text(&self) -> Option<&str> {
        self.get_struct(StructAttr::ALT_TEXT).map(StructAttr::unwrap_alt_text)
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn set_alt_text(&mut self, alt_text: Option<String>) {
        self.set_or_remove_struct(StructAttr::ALT_TEXT, alt_text.map(StructAttr::AltText));
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn with_alt_text(mut self, alt_text: Option<String>) -> Self {
        self.set_alt_text(alt_text);
        self
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn expanded(&self) -> Option<&str> {
        self.get_struct(StructAttr::EXPANDED).map(StructAttr::unwrap_expanded)
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn set_expanded(&mut self, expanded: Option<String>) {
        self.set_or_remove_struct(StructAttr::EXPANDED, expanded.map(StructAttr::Expanded));
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn with_expanded(mut self, expanded: Option<String>) -> Self {
        self.set_expanded(expanded);
        self
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn actual_text(&self) -> Option<&str> {
        self.get_struct(StructAttr::ACTUAL_TEXT).map(StructAttr::unwrap_actual_text)
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn set_actual_text(&mut self, actual_text: Option<String>) {
        self.set_or_remove_struct(StructAttr::ACTUAL_TEXT, actual_text.map(StructAttr::ActualText));
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn with_actual_text(mut self, actual_text: Option<String>) -> Self {
        self.set_actual_text(actual_text);
        self
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn title(&self) -> Option<&str> {
        self.get_struct(StructAttr::TITLE).map(StructAttr::unwrap_title)
    }

    /// The heading level
    pub fn level(&self) -> Option<NonZeroU32> {
        self.get_struct(StructAttr::HEADING_LEVEL).map(StructAttr::unwrap_level)
    }

    /// The list numbering.
    pub fn numbering(&self) -> Option<ListNumbering> {
        self.get_list(ListAttr::NUMBERING).map(ListAttr::unwrap_numbering)
    }

    /// The table summary.
    pub fn summary(&self) -> Option<&str> {
        self.get_table(TableAttr::SUMMARY).map(TableAttr::unwrap_summary)
    }

    /// The table header scope.
    pub fn scope(&self) -> Option<TableHeaderScope> {
        self.get_table(TableAttr::HEADER_SCOPE).map(TableAttr::unwrap_scope)
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn headers(&self) -> Option<&[TagId]> {
        self.get_table(TableAttr::CELL_HEADERS).map(TableAttr::unwrap_headers)
    }

    /// The row span of this table cell.
    pub fn row_span(&self) -> Option<NonZeroU32> {
        self.get_table(TableAttr::ROW_SPAN).map(TableAttr::unwrap_row_span)
    }

    /// The column span of this table cell.
    pub fn col_span(&self) -> Option<NonZeroU32> {
        self.get_table(TableAttr::COL_SPAN).map(TableAttr::unwrap_col_span)
    }

    /// The placement.
    pub fn placement(&self) -> Option<Placement> {
        self.get_layout(LayoutAttr::PLACEMENT).map(LayoutAttr::unwrap_placement)
    }

    /// The placement.
    pub fn set_placement(&mut self, placement: Option<Placement>) {
        self.set_or_remove_layout(LayoutAttr::PLACEMENT, placement.map(LayoutAttr::Placement));
    }

    /// The placement.
    pub fn with_placement(mut self, placement: Option<Placement>) -> Self {
        self.set_placement(placement);
        self
    }

    /// The writing mode.
    pub fn writing_mode(&self) -> Option<WritingMode> {
        self.get_layout(LayoutAttr::WRITING_MODE).map(LayoutAttr::unwrap_writing_mode)
    }

    /// The writing mode.
    pub fn set_writing_mode(&mut self, writing_mode: Option<WritingMode>) {
        self.set_or_remove_layout(LayoutAttr::WRITING_MODE, writing_mode.map(LayoutAttr::WritingMode));
    }

    /// The writing mode.
    pub fn with_writing_mode(mut self, writing_mode: Option<WritingMode>) -> Self {
        self.set_writing_mode(writing_mode);
        self
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.get_layout(LayoutAttr::B_BOX).map(LayoutAttr::unwrap_bbox)
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.get_layout(LayoutAttr::WIDTH).map(LayoutAttr::unwrap_width)
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.get_layout(LayoutAttr::HEIGHT).map(LayoutAttr::unwrap_height)
    }
}

impl<T> Tag<T> {

    /// The tag id.
    pub fn id(&self) -> Option<&TagId> {
        self.inner.get_struct(StructAttr::ID).map(StructAttr::unwrap_id)
    }

    /// The tag id.
    pub fn set_id(&mut self, id: Option<TagId>) {
        self.inner.set_or_remove_struct(StructAttr::ID, id.map(StructAttr::Id));
    }

    /// The tag id.
    pub fn with_id(mut self, id: Option<TagId>) -> Self {
        self.set_id(id);
        self
    }

    /// The language of this tag.
    pub fn lang(&self) -> Option<&str> {
        self.inner.get_struct(StructAttr::LANG).map(StructAttr::unwrap_lang)
    }

    /// The language of this tag.
    pub fn set_lang(&mut self, lang: Option<String>) {
        self.inner.set_or_remove_struct(StructAttr::LANG, lang.map(StructAttr::Lang));
    }

    /// The language of this tag.
    pub fn with_lang(mut self, lang: Option<String>) -> Self {
        self.set_lang(lang);
        self
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn alt_text(&self) -> Option<&str> {
        self.inner.get_struct(StructAttr::ALT_TEXT).map(StructAttr::unwrap_alt_text)
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn set_alt_text(&mut self, alt_text: Option<String>) {
        self.inner.set_or_remove_struct(StructAttr::ALT_TEXT, alt_text.map(StructAttr::AltText));
    }

    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    pub fn with_alt_text(mut self, alt_text: Option<String>) -> Self {
        self.set_alt_text(alt_text);
        self
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn expanded(&self) -> Option<&str> {
        self.inner.get_struct(StructAttr::EXPANDED).map(StructAttr::unwrap_expanded)
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn set_expanded(&mut self, expanded: Option<String>) {
        self.inner.set_or_remove_struct(StructAttr::EXPANDED, expanded.map(StructAttr::Expanded));
    }

    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    pub fn with_expanded(mut self, expanded: Option<String>) -> Self {
        self.set_expanded(expanded);
        self
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn actual_text(&self) -> Option<&str> {
        self.inner.get_struct(StructAttr::ACTUAL_TEXT).map(StructAttr::unwrap_actual_text)
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn set_actual_text(&mut self, actual_text: Option<String>) {
        self.inner.set_or_remove_struct(StructAttr::ACTUAL_TEXT, actual_text.map(StructAttr::ActualText));
    }

    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    pub fn with_actual_text(mut self, actual_text: Option<String>) -> Self {
        self.set_actual_text(actual_text);
        self
    }

    /// The placement.
    pub fn placement(&self) -> Option<Placement> {
        self.inner.get_layout(LayoutAttr::PLACEMENT).map(LayoutAttr::unwrap_placement)
    }

    /// The placement.
    pub fn set_placement(&mut self, placement: Option<Placement>) {
        self.inner.set_or_remove_layout(LayoutAttr::PLACEMENT, placement.map(LayoutAttr::Placement));
    }

    /// The placement.
    pub fn with_placement(mut self, placement: Option<Placement>) -> Self {
        self.set_placement(placement);
        self
    }

    /// The writing mode.
    pub fn writing_mode(&self) -> Option<WritingMode> {
        self.inner.get_layout(LayoutAttr::WRITING_MODE).map(LayoutAttr::unwrap_writing_mode)
    }

    /// The writing mode.
    pub fn set_writing_mode(&mut self, writing_mode: Option<WritingMode>) {
        self.inner.set_or_remove_layout(LayoutAttr::WRITING_MODE, writing_mode.map(LayoutAttr::WritingMode));
    }

    /// The writing mode.
    pub fn with_writing_mode(mut self, writing_mode: Option<WritingMode>) -> Self {
        self.set_writing_mode(writing_mode);
        self
    }
}

/// Tag kind structs.
pub mod kind {
    /// A part of a document that may contain multiple articles or sections.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Part;

    /// An article with largely self-contained content.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Article;

    /// Section of a larger document.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Section;

    /// A paragraph-level quote.
    #[derive(Clone, Debug, PartialEq)]
    pub struct BlockQuote;

    /// An image or figure caption.
    ///
    /// **Best Practice**: In the tag tree, this should appear
    /// as a sibling after the image (or other) content it describes.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Caption;

    /// Table of contents.
    ///
    /// **Best Practice**: Should consist of TOCIs or other nested TOCs.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TOC;

    /// Item in the table of contents.
    ///
    /// **Best Practice**: Should only appear within a TOC. Should only consist of
    /// labels, references, paragraphs and TOCs.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TOCI;

    /// Index of the key terms in the document.
    ///
    /// **Best Practice**: Should contain a sequence of text accompanied by
    /// reference elements pointing to their occurrence in the text.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Index;

    /// A paragraph.
    #[derive(Clone, Debug, PartialEq)]
    pub struct P;

    /// Heading level `n`, including an optional title of the heading.
    ///
    /// The title is required for some export modes, like for example PDF/UA.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Hn;

    /// A list.
    ///
    /// **Best practice**: Should consist of an optional caption followed by
    /// list items.
    /// List numbering is only required for PDF/UA, but we just enforce it for always.
    #[derive(Clone, Debug, PartialEq)]
    pub struct L;

    /// A list item.
    ///
    /// **Best practice**: Should consist of one or more list labels and/or list bodies.
    #[derive(Clone, Debug, PartialEq)]
    pub struct LI;

    /// Label for a list item.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Lbl;

    /// Description of the list item.
    #[derive(Clone, Debug, PartialEq)]
    pub struct LBody;

    /// A table, with an optional summary describing the purpose and structure.
    ///
    /// **Best practice**: Should consist of an optional table header row,
    /// one or more table body elements and an optional table footer. Can have
    /// caption as the first or last child.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Table;

    /// A table row.
    ///
    /// **Best practice**: May contain table headers cells and table data cells.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TR;

    /// A table header cell.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TH;

    /// A table data cell.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TD;

    /// A table header row group.
    #[derive(Clone, Debug, PartialEq)]
    pub struct THead;

    /// A table data row group.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TBody;

    /// A table footer row group.
    #[derive(Clone, Debug, PartialEq)]
    pub struct TFoot;

    /// An inline quotation.
    #[derive(Clone, Debug, PartialEq)]
    pub struct InlineQuote;

    /// A foot- or endnote, potentially referred to from within the text.
    ///
    /// **Best practice**: It may have a label as a child.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Note;

    /// A reference to elsewhere in the document.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to a destination in the document, and the second child should consist of
    /// the children that should be associated with that reference.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Reference;

    /// A reference to the external source of some cited document.
    ///
    /// **Best practice**: It may have a label as a child.
    #[derive(Clone, Debug, PartialEq)]
    pub struct BibEntry;

    /// Computer code.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Code;

    /// A link.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to an URL, and the second child should consist of the children that should
    /// be associated with that link.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Link;

    /// An association between an annotation and the content it belongs to. PDF
    ///
    /// **Best practice**: Should be used for all annotations, except for link annotations and
    /// widget annotations. The first child should be the identifier of a non-link annotation,
    /// and all other subsequent children should be content identifiers associated with that
    /// annotation.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Annot;

    /// Item of graphical content.
    ///
    /// Providing `alt_text` is required in some export modes, like for example PDF/UA1.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Figure;

    /// A mathematical formula.
    ///
    /// Providing `alt_text` is required in some export modes, like for example PDF/UA1.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Formula;

    /// A date or time.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Datetime;

    /// A list of terms.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Terms;

    /// A title.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Title;

}

impl From<Tag<kind::Part>> for TagKind {
    fn from(value: Tag<kind::Part>) -> Self {
        Self::Part(value)
    }
}
impl Tag<kind::Part> {
    /// A part of a document that may contain multiple articles or sections.
    #[allow(non_upper_case_globals)]
    pub const Part: Tag<kind::Part> = Tag::new();
}

impl From<Tag<kind::Article>> for TagKind {
    fn from(value: Tag<kind::Article>) -> Self {
        Self::Article(value)
    }
}
impl Tag<kind::Article> {
    /// An article with largely self-contained content.
    #[allow(non_upper_case_globals)]
    pub const Article: Tag<kind::Article> = Tag::new();
}

impl From<Tag<kind::Section>> for TagKind {
    fn from(value: Tag<kind::Section>) -> Self {
        Self::Section(value)
    }
}
impl Tag<kind::Section> {
    /// Section of a larger document.
    #[allow(non_upper_case_globals)]
    pub const Section: Tag<kind::Section> = Tag::new();
}

impl From<Tag<kind::BlockQuote>> for TagKind {
    fn from(value: Tag<kind::BlockQuote>) -> Self {
        Self::BlockQuote(value)
    }
}
impl Tag<kind::BlockQuote> {
    /// A paragraph-level quote.
    #[allow(non_upper_case_globals)]
    pub const BlockQuote: Tag<kind::BlockQuote> = Tag::new();
}

impl From<Tag<kind::Caption>> for TagKind {
    fn from(value: Tag<kind::Caption>) -> Self {
        Self::Caption(value)
    }
}
impl Tag<kind::Caption> {
    /// An image or figure caption.
    ///
    /// **Best Practice**: In the tag tree, this should appear
    /// as a sibling after the image (or other) content it describes.
    #[allow(non_upper_case_globals)]
    pub const Caption: Tag<kind::Caption> = Tag::new();
}

impl From<Tag<kind::TOC>> for TagKind {
    fn from(value: Tag<kind::TOC>) -> Self {
        Self::TOC(value)
    }
}
impl Tag<kind::TOC> {
    /// Table of contents.
    ///
    /// **Best Practice**: Should consist of TOCIs or other nested TOCs.
    #[allow(non_upper_case_globals)]
    pub const TOC: Tag<kind::TOC> = Tag::new();
}

impl From<Tag<kind::TOCI>> for TagKind {
    fn from(value: Tag<kind::TOCI>) -> Self {
        Self::TOCI(value)
    }
}
impl Tag<kind::TOCI> {
    /// Item in the table of contents.
    ///
    /// **Best Practice**: Should only appear within a TOC. Should only consist of
    /// labels, references, paragraphs and TOCs.
    #[allow(non_upper_case_globals)]
    pub const TOCI: Tag<kind::TOCI> = Tag::new();
}

impl From<Tag<kind::Index>> for TagKind {
    fn from(value: Tag<kind::Index>) -> Self {
        Self::Index(value)
    }
}
impl Tag<kind::Index> {
    /// Index of the key terms in the document.
    ///
    /// **Best Practice**: Should contain a sequence of text accompanied by
    /// reference elements pointing to their occurrence in the text.
    #[allow(non_upper_case_globals)]
    pub const Index: Tag<kind::Index> = Tag::new();
}

impl From<Tag<kind::P>> for TagKind {
    fn from(value: Tag<kind::P>) -> Self {
        Self::P(value)
    }
}
impl Tag<kind::P> {
    /// A paragraph.
    #[allow(non_upper_case_globals)]
    pub const P: Tag<kind::P> = Tag::new();
}

impl From<Tag<kind::Hn>> for TagKind {
    fn from(value: Tag<kind::Hn>) -> Self {
        Self::Hn(value)
    }
}
impl Tag<kind::Hn> {
    /// Heading level `n`, including an optional title of the heading.
    ///
    /// The title is required for some export modes, like for example PDF/UA.
    #[allow(non_snake_case)]
    pub fn Hn(level: NonZeroU32, title: Option<String>) -> Tag<kind::Hn> {
        let mut tag = Tag::new();
        tag.set_level(level);
        tag.set_title(title);
        tag
    }

    /// The heading level
    pub fn level(&self) -> NonZeroU32 {
        self.inner.get_struct(StructAttr::HEADING_LEVEL).unwrap().unwrap_level()
    }

    /// The heading level
    pub fn set_level(&mut self, level: NonZeroU32) {
        self.inner.set_struct(StructAttr::HeadingLevel(level));
    }

    /// The heading level
    pub fn with_level(mut self, level: NonZeroU32) -> Self {
        self.set_level(level);
        self
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn title(&self) -> Option<&str> {
        self.inner.get_struct(StructAttr::TITLE).map(StructAttr::unwrap_title)
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn set_title(&mut self, title: Option<String>) {
        self.inner.set_or_remove_struct(StructAttr::TITLE, title.map(StructAttr::Title));
    }

    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    pub fn with_title(mut self, title: Option<String>) -> Self {
        self.set_title(title);
        self
    }
}

impl From<Tag<kind::L>> for TagKind {
    fn from(value: Tag<kind::L>) -> Self {
        Self::L(value)
    }
}
impl Tag<kind::L> {
    /// A list.
    ///
    /// **Best practice**: Should consist of an optional caption followed by
    /// list items.
    /// List numbering is only required for PDF/UA, but we just enforce it for always.
    #[allow(non_snake_case)]
    pub fn L(numbering: ListNumbering) -> Tag<kind::L> {
        let mut tag = Tag::new();
        tag.set_numbering(numbering);
        tag
    }

    /// The list numbering.
    pub fn numbering(&self) -> ListNumbering {
        self.inner.get_list(ListAttr::NUMBERING).unwrap().unwrap_numbering()
    }

    /// The list numbering.
    pub fn set_numbering(&mut self, numbering: ListNumbering) {
        self.inner.set_list(ListAttr::Numbering(numbering));
    }

    /// The list numbering.
    pub fn with_numbering(mut self, numbering: ListNumbering) -> Self {
        self.set_numbering(numbering);
        self
    }
}

impl From<Tag<kind::LI>> for TagKind {
    fn from(value: Tag<kind::LI>) -> Self {
        Self::LI(value)
    }
}
impl Tag<kind::LI> {
    /// A list item.
    ///
    /// **Best practice**: Should consist of one or more list labels and/or list bodies.
    #[allow(non_upper_case_globals)]
    pub const LI: Tag<kind::LI> = Tag::new();
}

impl From<Tag<kind::Lbl>> for TagKind {
    fn from(value: Tag<kind::Lbl>) -> Self {
        Self::Lbl(value)
    }
}
impl Tag<kind::Lbl> {
    /// Label for a list item.
    #[allow(non_upper_case_globals)]
    pub const Lbl: Tag<kind::Lbl> = Tag::new();
}

impl From<Tag<kind::LBody>> for TagKind {
    fn from(value: Tag<kind::LBody>) -> Self {
        Self::LBody(value)
    }
}
impl Tag<kind::LBody> {
    /// Description of the list item.
    #[allow(non_upper_case_globals)]
    pub const LBody: Tag<kind::LBody> = Tag::new();
}

impl From<Tag<kind::Table>> for TagKind {
    fn from(value: Tag<kind::Table>) -> Self {
        Self::Table(value)
    }
}
impl Tag<kind::Table> {
    /// A table, with an optional summary describing the purpose and structure.
    ///
    /// **Best practice**: Should consist of an optional table header row,
    /// one or more table body elements and an optional table footer. Can have
    /// caption as the first or last child.
    #[allow(non_upper_case_globals)]
    pub const Table: Tag<kind::Table> = Tag::new();

    /// The table summary.
    pub fn summary(&self) -> Option<&str> {
        self.inner.get_table(TableAttr::SUMMARY).map(TableAttr::unwrap_summary)
    }

    /// The table summary.
    pub fn set_summary(&mut self, summary: Option<String>) {
        self.inner.set_or_remove_table(TableAttr::SUMMARY, summary.map(TableAttr::Summary));
    }

    /// The table summary.
    pub fn with_summary(mut self, summary: Option<String>) -> Self {
        self.set_summary(summary);
        self
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.inner.get_layout(LayoutAttr::B_BOX).map(LayoutAttr::unwrap_bbox)
    }

    /// The bounding box.
    pub fn set_bbox(&mut self, bbox: Option<Rect>) {
        self.inner.set_or_remove_layout(LayoutAttr::B_BOX, bbox.map(LayoutAttr::BBox));
    }

    /// The bounding box.
    pub fn with_bbox(mut self, bbox: Option<Rect>) -> Self {
        self.set_bbox(bbox);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::WIDTH).map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::WIDTH, width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::HEIGHT).map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::HEIGHT, height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

impl From<Tag<kind::TR>> for TagKind {
    fn from(value: Tag<kind::TR>) -> Self {
        Self::TR(value)
    }
}
impl Tag<kind::TR> {
    /// A table row.
    ///
    /// **Best practice**: May contain table headers cells and table data cells.
    #[allow(non_upper_case_globals)]
    pub const TR: Tag<kind::TR> = Tag::new();
}

impl From<Tag<kind::TH>> for TagKind {
    fn from(value: Tag<kind::TH>) -> Self {
        Self::TH(value)
    }
}
impl Tag<kind::TH> {
    /// A table header cell.
    #[allow(non_snake_case)]
    pub fn TH(scope: TableHeaderScope) -> Tag<kind::TH> {
        let mut tag = Tag::new();
        tag.set_scope(scope);
        tag
    }

    /// The table header scope.
    pub fn scope(&self) -> TableHeaderScope {
        self.inner.get_table(TableAttr::HEADER_SCOPE).unwrap().unwrap_scope()
    }

    /// The table header scope.
    pub fn set_scope(&mut self, scope: TableHeaderScope) {
        self.inner.set_table(TableAttr::HeaderScope(scope));
    }

    /// The table header scope.
    pub fn with_scope(mut self, scope: TableHeaderScope) -> Self {
        self.set_scope(scope);
        self
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn headers(&self) -> Option<&[TagId]> {
        self.inner.get_table(TableAttr::CELL_HEADERS).map(TableAttr::unwrap_headers)
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn set_headers(&mut self, headers: impl IntoIterator<Item = TagId>) {
        self.inner.set_table(TableAttr::CellHeaders(headers.into_iter().collect()));
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn with_headers(mut self, headers: impl IntoIterator<Item = TagId>) -> Self {
        self.set_headers(headers);
        self
    }

    /// The row span of this table cell.
    pub fn row_span(&self) -> Option<NonZeroU32> {
        self.inner.get_table(TableAttr::ROW_SPAN).map(TableAttr::unwrap_row_span)
    }

    /// The row span of this table cell.
    pub fn set_row_span(&mut self, row_span: Option<NonZeroU32>) {
        self.inner.set_or_remove_table(TableAttr::ROW_SPAN, row_span.map(TableAttr::RowSpan));
    }

    /// The row span of this table cell.
    pub fn with_row_span(mut self, row_span: Option<NonZeroU32>) -> Self {
        self.set_row_span(row_span);
        self
    }

    /// The column span of this table cell.
    pub fn col_span(&self) -> Option<NonZeroU32> {
        self.inner.get_table(TableAttr::COL_SPAN).map(TableAttr::unwrap_col_span)
    }

    /// The column span of this table cell.
    pub fn set_col_span(&mut self, col_span: Option<NonZeroU32>) {
        self.inner.set_or_remove_table(TableAttr::COL_SPAN, col_span.map(TableAttr::ColSpan));
    }

    /// The column span of this table cell.
    pub fn with_col_span(mut self, col_span: Option<NonZeroU32>) -> Self {
        self.set_col_span(col_span);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::WIDTH).map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::WIDTH, width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::HEIGHT).map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::HEIGHT, height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

impl From<Tag<kind::TD>> for TagKind {
    fn from(value: Tag<kind::TD>) -> Self {
        Self::TD(value)
    }
}
impl Tag<kind::TD> {
    /// A table data cell.
    #[allow(non_upper_case_globals)]
    pub const TD: Tag<kind::TD> = Tag::new();

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn headers(&self) -> Option<&[TagId]> {
        self.inner.get_table(TableAttr::CELL_HEADERS).map(TableAttr::unwrap_headers)
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn set_headers(&mut self, headers: impl IntoIterator<Item = TagId>) {
        self.inner.set_table(TableAttr::CellHeaders(headers.into_iter().collect()));
    }

    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    pub fn with_headers(mut self, headers: impl IntoIterator<Item = TagId>) -> Self {
        self.set_headers(headers);
        self
    }

    /// The row span of this table cell.
    pub fn row_span(&self) -> Option<NonZeroU32> {
        self.inner.get_table(TableAttr::ROW_SPAN).map(TableAttr::unwrap_row_span)
    }

    /// The row span of this table cell.
    pub fn set_row_span(&mut self, row_span: Option<NonZeroU32>) {
        self.inner.set_or_remove_table(TableAttr::ROW_SPAN, row_span.map(TableAttr::RowSpan));
    }

    /// The row span of this table cell.
    pub fn with_row_span(mut self, row_span: Option<NonZeroU32>) -> Self {
        self.set_row_span(row_span);
        self
    }

    /// The column span of this table cell.
    pub fn col_span(&self) -> Option<NonZeroU32> {
        self.inner.get_table(TableAttr::COL_SPAN).map(TableAttr::unwrap_col_span)
    }

    /// The column span of this table cell.
    pub fn set_col_span(&mut self, col_span: Option<NonZeroU32>) {
        self.inner.set_or_remove_table(TableAttr::COL_SPAN, col_span.map(TableAttr::ColSpan));
    }

    /// The column span of this table cell.
    pub fn with_col_span(mut self, col_span: Option<NonZeroU32>) -> Self {
        self.set_col_span(col_span);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::WIDTH).map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::WIDTH, width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::HEIGHT).map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::HEIGHT, height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

impl From<Tag<kind::THead>> for TagKind {
    fn from(value: Tag<kind::THead>) -> Self {
        Self::THead(value)
    }
}
impl Tag<kind::THead> {
    /// A table header row group.
    #[allow(non_upper_case_globals)]
    pub const THead: Tag<kind::THead> = Tag::new();
}

impl From<Tag<kind::TBody>> for TagKind {
    fn from(value: Tag<kind::TBody>) -> Self {
        Self::TBody(value)
    }
}
impl Tag<kind::TBody> {
    /// A table data row group.
    #[allow(non_upper_case_globals)]
    pub const TBody: Tag<kind::TBody> = Tag::new();
}

impl From<Tag<kind::TFoot>> for TagKind {
    fn from(value: Tag<kind::TFoot>) -> Self {
        Self::TFoot(value)
    }
}
impl Tag<kind::TFoot> {
    /// A table footer row group.
    #[allow(non_upper_case_globals)]
    pub const TFoot: Tag<kind::TFoot> = Tag::new();
}

impl From<Tag<kind::InlineQuote>> for TagKind {
    fn from(value: Tag<kind::InlineQuote>) -> Self {
        Self::InlineQuote(value)
    }
}
impl Tag<kind::InlineQuote> {
    /// An inline quotation.
    #[allow(non_upper_case_globals)]
    pub const InlineQuote: Tag<kind::InlineQuote> = Tag::new();
}

impl From<Tag<kind::Note>> for TagKind {
    fn from(value: Tag<kind::Note>) -> Self {
        Self::Note(value)
    }
}
impl Tag<kind::Note> {
    /// A foot- or endnote, potentially referred to from within the text.
    ///
    /// **Best practice**: It may have a label as a child.
    #[allow(non_upper_case_globals)]
    pub const Note: Tag<kind::Note> = Tag::new();
}

impl From<Tag<kind::Reference>> for TagKind {
    fn from(value: Tag<kind::Reference>) -> Self {
        Self::Reference(value)
    }
}
impl Tag<kind::Reference> {
    /// A reference to elsewhere in the document.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to a destination in the document, and the second child should consist of
    /// the children that should be associated with that reference.
    #[allow(non_upper_case_globals)]
    pub const Reference: Tag<kind::Reference> = Tag::new();
}

impl From<Tag<kind::BibEntry>> for TagKind {
    fn from(value: Tag<kind::BibEntry>) -> Self {
        Self::BibEntry(value)
    }
}
impl Tag<kind::BibEntry> {
    /// A reference to the external source of some cited document.
    ///
    /// **Best practice**: It may have a label as a child.
    #[allow(non_upper_case_globals)]
    pub const BibEntry: Tag<kind::BibEntry> = Tag::new();
}

impl From<Tag<kind::Code>> for TagKind {
    fn from(value: Tag<kind::Code>) -> Self {
        Self::Code(value)
    }
}
impl Tag<kind::Code> {
    /// Computer code.
    #[allow(non_upper_case_globals)]
    pub const Code: Tag<kind::Code> = Tag::new();
}

impl From<Tag<kind::Link>> for TagKind {
    fn from(value: Tag<kind::Link>) -> Self {
        Self::Link(value)
    }
}
impl Tag<kind::Link> {
    /// A link.
    ///
    /// **Best practice**: The first child of a tag group with this tag should be a link annotation
    /// linking to an URL, and the second child should consist of the children that should
    /// be associated with that link.
    #[allow(non_upper_case_globals)]
    pub const Link: Tag<kind::Link> = Tag::new();
}

impl From<Tag<kind::Annot>> for TagKind {
    fn from(value: Tag<kind::Annot>) -> Self {
        Self::Annot(value)
    }
}
impl Tag<kind::Annot> {
    /// An association between an annotation and the content it belongs to. PDF
    ///
    /// **Best practice**: Should be used for all annotations, except for link annotations and
    /// widget annotations. The first child should be the identifier of a non-link annotation,
    /// and all other subsequent children should be content identifiers associated with that
    /// annotation.
    #[allow(non_upper_case_globals)]
    pub const Annot: Tag<kind::Annot> = Tag::new();
}

impl From<Tag<kind::Figure>> for TagKind {
    fn from(value: Tag<kind::Figure>) -> Self {
        Self::Figure(value)
    }
}
impl Tag<kind::Figure> {
    /// Item of graphical content.
    ///
    /// Providing `alt_text` is required in some export modes, like for example PDF/UA1.
    #[allow(non_snake_case)]
    pub fn Figure(alt_text: Option<String>) -> Tag<kind::Figure> {
        let mut tag = Tag::new();
        tag.set_alt_text(alt_text);
        tag
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.inner.get_layout(LayoutAttr::B_BOX).map(LayoutAttr::unwrap_bbox)
    }

    /// The bounding box.
    pub fn set_bbox(&mut self, bbox: Option<Rect>) {
        self.inner.set_or_remove_layout(LayoutAttr::B_BOX, bbox.map(LayoutAttr::BBox));
    }

    /// The bounding box.
    pub fn with_bbox(mut self, bbox: Option<Rect>) -> Self {
        self.set_bbox(bbox);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::WIDTH).map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::WIDTH, width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::HEIGHT).map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::HEIGHT, height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

impl From<Tag<kind::Formula>> for TagKind {
    fn from(value: Tag<kind::Formula>) -> Self {
        Self::Formula(value)
    }
}
impl Tag<kind::Formula> {
    /// A mathematical formula.
    ///
    /// Providing `alt_text` is required in some export modes, like for example PDF/UA1.
    #[allow(non_snake_case)]
    pub fn Formula(alt_text: Option<String>) -> Tag<kind::Formula> {
        let mut tag = Tag::new();
        tag.set_alt_text(alt_text);
        tag
    }

    /// The bounding box.
    pub fn bbox(&self) -> Option<Rect> {
        self.inner.get_layout(LayoutAttr::B_BOX).map(LayoutAttr::unwrap_bbox)
    }

    /// The bounding box.
    pub fn set_bbox(&mut self, bbox: Option<Rect>) {
        self.inner.set_or_remove_layout(LayoutAttr::B_BOX, bbox.map(LayoutAttr::BBox));
    }

    /// The bounding box.
    pub fn with_bbox(mut self, bbox: Option<Rect>) -> Self {
        self.set_bbox(bbox);
        self
    }

    /// The width.
    pub fn width(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::WIDTH).map(LayoutAttr::unwrap_width)
    }

    /// The width.
    pub fn set_width(&mut self, width: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::WIDTH, width.map(LayoutAttr::Width));
    }

    /// The width.
    pub fn with_width(mut self, width: Option<f32>) -> Self {
        self.set_width(width);
        self
    }

    /// The height.
    pub fn height(&self) -> Option<f32> {
        self.inner.get_layout(LayoutAttr::HEIGHT).map(LayoutAttr::unwrap_height)
    }

    /// The height.
    pub fn set_height(&mut self, height: Option<f32>) {
        self.inner.set_or_remove_layout(LayoutAttr::HEIGHT, height.map(LayoutAttr::Height));
    }

    /// The height.
    pub fn with_height(mut self, height: Option<f32>) -> Self {
        self.set_height(height);
        self
    }
}

impl From<Tag<kind::Datetime>> for TagKind {
    fn from(value: Tag<kind::Datetime>) -> Self {
        Self::Datetime(value)
    }
}
impl Tag<kind::Datetime> {
    /// A date or time.
    #[allow(non_upper_case_globals)]
    pub const Datetime: Tag<kind::Datetime> = Tag::new();
}

impl From<Tag<kind::Terms>> for TagKind {
    fn from(value: Tag<kind::Terms>) -> Self {
        Self::Terms(value)
    }
}
impl Tag<kind::Terms> {
    /// A list of terms.
    #[allow(non_upper_case_globals)]
    pub const Terms: Tag<kind::Terms> = Tag::new();
}

impl From<Tag<kind::Title>> for TagKind {
    fn from(value: Tag<kind::Title>) -> Self {
        Self::Title(value)
    }
}
impl Tag<kind::Title> {
    /// A title.
    #[allow(non_upper_case_globals)]
    pub const Title: Tag<kind::Title> = Tag::new();
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum Attr {
    Struct(StructAttr),
    List(ListAttr),
    Table(TableAttr),
    Layout(LayoutAttr),
}

impl Attr {

        #[inline(always)]
        fn unwrap_struct(&self) -> &StructAttr {
            match self {
                Self::Struct(attr) => attr,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_list(&self) -> &ListAttr {
            match self {
                Self::List(attr) => attr,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_table(&self) -> &TableAttr {
            match self {
                Self::Table(attr) => attr,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_layout(&self) -> &LayoutAttr {
            match self {
                Self::Layout(attr) => attr,
                _ => unreachable!(),
            }
        }
}
impl Ordinal for Attr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Struct(a) => a.ordinal(),
            Self::List(a) => a.ordinal(),
            Self::Table(a) => a.ordinal(),
            Self::Layout(a) => a.ordinal(),
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum StructAttr {
    /// The tag id.
    Id(TagId),
    /// The language of this tag.
    Lang(String),
    /// An optional alternate text that describes the text (for example, if the text consists
    /// of a star symbol, the alt text should describe that in natural language).
    AltText(String),
    /// If the content of the tag is an abbreviation, the expanded form of the
    /// abbreviation should be provided here.
    Expanded(String),
    /// The actual text represented by the content of this tag, i.e. if it contained
    /// some curves that artistically represent some word. This should be the exact
    /// replacement text of the word.
    ActualText(String),
    /// The title, characterizing a specific tag such as `"Chapter 1"`.
    Title(String),
    /// The heading level
    HeadingLevel(NonZeroU32),
}

impl StructAttr {
    pub(crate) const ID: usize = 0;
    pub(crate) const LANG: usize = 1;
    pub(crate) const ALT_TEXT: usize = 2;
    pub(crate) const EXPANDED: usize = 3;
    pub(crate) const ACTUAL_TEXT: usize = 4;
    pub(crate) const TITLE: usize = 5;
    pub(crate) const HEADING_LEVEL: usize = 6;

        #[inline(always)]
        fn unwrap_id(&self) -> &TagId {
            match self {
                Self::Id(val) => val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_lang(&self) -> &str {
            match self {
                Self::Lang(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_alt_text(&self) -> &str {
            match self {
                Self::AltText(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_expanded(&self) -> &str {
            match self {
                Self::Expanded(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_actual_text(&self) -> &str {
            match self {
                Self::ActualText(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_title(&self) -> &str {
            match self {
                Self::Title(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_level(&self) -> NonZeroU32 {
            match self {
                Self::HeadingLevel(val) => *val,
                _ => unreachable!(),
            }
        }
}

impl Ordinal for StructAttr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Id(_) => Self::ID,
            Self::Lang(_) => Self::LANG,
            Self::AltText(_) => Self::ALT_TEXT,
            Self::Expanded(_) => Self::EXPANDED,
            Self::ActualText(_) => Self::ACTUAL_TEXT,
            Self::Title(_) => Self::TITLE,
            Self::HeadingLevel(_) => Self::HEADING_LEVEL,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum ListAttr {
    /// The list numbering.
    Numbering(ListNumbering),
}

impl ListAttr {
    pub(crate) const NUMBERING: usize = 7;

        #[inline(always)]
        fn unwrap_numbering(&self) -> ListNumbering {
            match self {
                Self::Numbering(val) => *val,
            }
        }
}

impl Ordinal for ListAttr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Numbering(_) => Self::NUMBERING,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum TableAttr {
    /// The table summary.
    Summary(String),
    /// The table header scope.
    HeaderScope(TableHeaderScope),
    /// A list of headers associated with a table cell.
    /// Table data cells (`TD`) may specify a list of table headers (`TH`),
    /// which can also specify a list of parent header cells (`TH`), and so on.
    /// To determine the list of associated headers this list is recursively
    /// evaluated.
    ///
    /// This allows specifying header hierarchies inside tables.
    CellHeaders(SmallVec<[TagId; 1]>),
    /// The row span of this table cell.
    RowSpan(NonZeroU32),
    /// The column span of this table cell.
    ColSpan(NonZeroU32),
}

impl TableAttr {
    pub(crate) const SUMMARY: usize = 8;
    pub(crate) const HEADER_SCOPE: usize = 9;
    pub(crate) const CELL_HEADERS: usize = 10;
    pub(crate) const ROW_SPAN: usize = 11;
    pub(crate) const COL_SPAN: usize = 12;

        #[inline(always)]
        fn unwrap_summary(&self) -> &str {
            match self {
                Self::Summary(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_scope(&self) -> TableHeaderScope {
            match self {
                Self::HeaderScope(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_headers(&self) -> &[TagId] {
            match self {
                Self::CellHeaders(val) => val.as_ref(),
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_row_span(&self) -> NonZeroU32 {
            match self {
                Self::RowSpan(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_col_span(&self) -> NonZeroU32 {
            match self {
                Self::ColSpan(val) => *val,
                _ => unreachable!(),
            }
        }
}

impl Ordinal for TableAttr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Summary(_) => Self::SUMMARY,
            Self::HeaderScope(_) => Self::HEADER_SCOPE,
            Self::CellHeaders(_) => Self::CELL_HEADERS,
            Self::RowSpan(_) => Self::ROW_SPAN,
            Self::ColSpan(_) => Self::COL_SPAN,
        }
    }
}

#[derive(Clone, Debug, PartialEq)]
pub(crate) enum LayoutAttr {
    /// The placement.
    Placement(Placement),
    /// The writing mode.
    WritingMode(WritingMode),
    /// The bounding box.
    BBox(Rect),
    /// The width.
    Width(f32),
    /// The height.
    Height(f32),
}

impl LayoutAttr {
    pub(crate) const PLACEMENT: usize = 13;
    pub(crate) const WRITING_MODE: usize = 14;
    pub(crate) const B_BOX: usize = 15;
    pub(crate) const WIDTH: usize = 16;
    pub(crate) const HEIGHT: usize = 17;

        #[inline(always)]
        fn unwrap_placement(&self) -> Placement {
            match self {
                Self::Placement(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_writing_mode(&self) -> WritingMode {
            match self {
                Self::WritingMode(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_bbox(&self) -> Rect {
            match self {
                Self::BBox(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_width(&self) -> f32 {
            match self {
                Self::Width(val) => *val,
                _ => unreachable!(),
            }
        }

        #[inline(always)]
        fn unwrap_height(&self) -> f32 {
            match self {
                Self::Height(val) => *val,
                _ => unreachable!(),
            }
        }
}

impl Ordinal for LayoutAttr {
    fn ordinal(&self) -> usize {
        match self {
            Self::Placement(_) => Self::PLACEMENT,
            Self::WritingMode(_) => Self::WRITING_MODE,
            Self::BBox(_) => Self::B_BOX,
            Self::Width(_) => Self::WIDTH,
            Self::Height(_) => Self::HEIGHT,
        }
    }
}

