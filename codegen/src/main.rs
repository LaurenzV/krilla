use std::sync::{LazyLock, OnceLock};

use convert_case::{Case, Casing};
use crates_common::{diagnostic, Pos, Span};
use crates_toml::container::{Container, Toml};
use crates_toml::map::{
    MapArray, MapArrayInline, MapArrayInlineEntry, MapNode, MapTableEntry, MapTableEntryRepr,
    Scalar,
};
use crates_toml::parse::AssocPos;
use crates_toml::{MapTable, TomlDiagnostics};
use indexmap::IndexMap;

const INPUT_PATH: &str = "crates/krilla/src/interchange/tagging/generate.toml";
const OUTPUT_PATH: &str = "crates/krilla/src/interchange/tagging/generated.rs";
const HEADER: &str = "\
// This file is automatically generated!
//
// To update it:
// 1. Edit the `generate.toml` file inside of this directory
// 2. Run `cargo run --bin=codegen` from the repository root

";

struct Tag<'a> {
    comments: Vec<&'a str>,
    variants: Vec<TagVariant<'a>>,
}

struct TagVariant<'a> {
    comments: Vec<&'a str>,
    name: &'a str,
    required: Vec<(&'a Attr<'a>, &'a AttrVariant<'a>)>,
    optional: Vec<(&'a Attr<'a>, &'a AttrVariant<'a>)>,
    suggested: Vec<(&'a Attr<'a>, &'a AttrVariant<'a>)>,
}

struct Attr<'a> {
    name: &'a str,
    variants: Vec<AttrVariant<'a>>,
    field: OnceLock<&'a str>,
}

impl Attr<'_> {
    fn field(&self) -> &str {
        self.field
            .get_or_init(|| (self.name.to_case(Case::Snake) + "s").leak())
    }
}

struct AttrVariant<'a> {
    span: Span,
    comments: Vec<&'a str>,
    name: &'a str,
    ty: &'a str,
    global: bool,
    accessor_name: OnceLock<&'a str>,
    accessor_kind: AccessorKind<'a>,
    ordinal_name: OnceLock<&'a str>,
    param_type: OnceLock<&'a str>,
    param_mapping: OnceLock<&'a str>,
    ret_type: OnceLock<&'a str>,
    ret_mapping: OnceLock<&'a str>,
}

impl AttrVariant<'_> {
    fn accessor_name(&self) -> &str {
        self.accessor_name
            .get_or_init(|| self.name.to_case(Case::Snake).leak())
    }

    fn ordinal_name(&self) -> &str {
        self.ordinal_name
            .get_or_init(|| self.name.to_case(Case::UpperSnake).leak())
    }

    fn param_type(&self) -> &str {
        self.param_type.get_or_init(|| match self.accessor_kind {
            AccessorKind::Normal => self.ty,
            AccessorKind::Copy => self.ty,
            AccessorKind::AsRef(_) => self.ty,
            AccessorKind::Custom => match self.name {
                "CellHeaders" => "impl IntoIterator<Item = TagId>",
                _ => report_error(
                    &format!(
                        "no custom parameter type rule implemented for `{}`",
                        self.name
                    ),
                    self.span,
                ),
            },
        })
    }

    fn param_mapping(&self) -> &str {
        self.param_mapping.get_or_init(|| match self.accessor_kind {
            AccessorKind::Normal | AccessorKind::Copy | AccessorKind::AsRef(_) => "",
            AccessorKind::Custom => match self.name {
                "CellHeaders" => ".into_iter().collect()",
                _ => report_error(
                    &format!("no custom return type rule implemented for `{}`", self.name),
                    self.span,
                ),
            },
        })
    }

    fn return_type(&self) -> &str {
        self.ret_type.get_or_init(|| match self.accessor_kind {
            AccessorKind::Normal => format!("&{}", self.ty).leak(),
            AccessorKind::Copy => self.ty,
            AccessorKind::AsRef(ret) => format!("&{ret}").leak(),
            AccessorKind::Custom => match self.name {
                "CellHeaders" => "&[TagId]",
                _ => report_error(
                    &format!("no custom return type rule implemented for `{}`", self.name),
                    self.span,
                ),
            },
        })
    }

    fn return_mapping(&self) -> &str {
        self.ret_mapping.get_or_init(|| match self.accessor_kind {
            AccessorKind::Normal => "",
            AccessorKind::Copy => ".clone()",
            AccessorKind::AsRef(_) => ".as_ref()",
            AccessorKind::Custom => match self.name {
                "CellHeaders" => ".as_ref()",
                _ => report_error(
                    &format!("no custom return type rule implemented for `{}`", self.name),
                    self.span,
                ),
            },
        })
    }
}

#[derive(Default, PartialEq, Eq)]
enum AccessorKind<'a> {
    #[default]
    Normal,
    Copy,
    AsRef(&'a str),
    Custom,
}

static TOML: LazyLock<&Toml> = LazyLock::new(|| {
    let input = std::fs::read_to_string(INPUT_PATH).unwrap();
    let mut ctx = TomlDiagnostics::default();
    let container = Container::parse(&mut ctx, &input);
    if !ctx.is_empty() {
        let mut buf = String::new();
        let lines = diagnostic::lines(&input);
        for error in ctx.errors.iter() {
            diagnostic::display(&mut buf, error, &lines).ok();
        }
        for warning in ctx.warnings.iter() {
            diagnostic::display(&mut buf, warning, &lines).ok();
        }
        for info in ctx.infos.iter() {
            diagnostic::display(&mut buf, info, &lines).ok();
        }
        println!("{buf}");
        std::process::exit(1);
    }
    let container = Box::leak(Box::new(container));
    container.toml()
});

static ATTRS: LazyLock<IndexMap<&str, Attr>> = LazyLock::new(|| {
    let mut attrs = IndexMap::new();
    parse_attr(&mut attrs, "Attr");
    parse_attr(&mut attrs, "ListAttr");
    parse_attr(&mut attrs, "TableAttr");
    parse_attr(&mut attrs, "LayoutAttr");
    attrs
});
static TAG: LazyLock<Tag> = LazyLock::new(parse_tag);

fn parse_attr(attrs: &mut IndexMap<&'static str, Attr>, name: &'static str) {
    let attr = (TOML.map)
        .expect_key(name, Span::pos(Pos::ZERO))
        .expect_table();

    let variants = attr.iter().map(|(variant_name, entry)| {
        let span = entry.reprs.first().repr_span();
        let variant = entry.expect_table();
        let ty = variant.expect_key("type", span).expect_str();
        let global = variant.get("global").is_some();
        let accessor_name = OnceLock::new();
        if let Some(e) = variant.get("name") {
            accessor_name.set(e.expect_str()).unwrap();
        }
        let accessor_kind = variant
            .get("accessor")
            .map(|e| match e.expect_str() {
                "Copy" => AccessorKind::Copy,
                "Custom" => AccessorKind::Custom,
                s if s.starts_with("AsRef<") && s.ends_with(">") => {
                    let ret_ty = s.strip_prefix("AsRef<").unwrap().strip_suffix(">").unwrap();
                    AccessorKind::AsRef(ret_ty)
                }
                _ => report_error("unknown accessor kind", e.reprs.first().repr_span()),
            })
            .unwrap_or_default();

        AttrVariant {
            span,
            comments: comment_lines(entry.reprs.first()),
            name: variant_name,
            ty,
            global,
            accessor_name,
            accessor_kind,
            ordinal_name: OnceLock::new(),
            param_type: OnceLock::new(),
            param_mapping: OnceLock::new(),
            ret_type: OnceLock::new(),
            ret_mapping: OnceLock::new(),
        }
    });

    let attr = Attr {
        name,
        variants: variants.collect(),
        field: OnceLock::new(),
    };
    attrs.insert(name, attr);
}

fn parse_tag() -> Tag<'static> {
    let entry = TOML.map.expect_key("Tag", Span::pos(Pos::ZERO));
    let comments = comment_lines(entry.reprs.first());

    let tag = entry.expect_table();
    let variants = tag.iter().map(|(variant_name, entry)| {
        let comments = comment_lines(entry.reprs.first());
        let variant = entry.expect_table();
        let required = variant.get("required").map(attribute_array);
        let optional = variant.get("optional").map(attribute_array);
        let suggested = variant.get("suggested").map(attribute_array);
        TagVariant {
            comments,
            name: variant_name,
            required: required.unwrap_or_default(),
            optional: optional.unwrap_or_default(),
            suggested: suggested.unwrap_or_default(),
        }
    });

    Tag {
        comments,
        variants: variants.collect(),
    }
}

fn main() {
    let mut output = String::new();
    output.push_str(HEADER);

    write_tag_kind(&mut output);
    for attr in ATTRS.values() {
        write_attr(&mut output, attr);
    }

    std::fs::write(OUTPUT_PATH, &output).unwrap();
}

fn attribute_array(
    entry: &MapTableEntry<'_>,
) -> Vec<(&'static Attr<'static>, &'static AttrVariant<'static>)> {
    let array = entry.expect_inline_array();
    let attrs = array.iter().map(|e| {
        let Some((attr_kind, attr_variant)) = e.expect_str().split_once("::") else {
            report_error(
                "expected `<attr-kind>::<attr-variant>`, for example `LayoutAttr::BBox`",
                e.repr.span(),
            )
        };

        let Some(attr) = ATTRS.get(attr_kind) else {
            report_error(
                &format!("Unknown attribute kind `{attr_kind}`"),
                e.repr.span(),
            );
        };

        let variant = attr
            .variants
            .iter()
            .find(|v| v.name == attr_variant)
            .unwrap_or_else(|| {
                report_error(
                    &format!("Unknown attribute variant `{attr_kind}::{attr_variant}`"),
                    e.repr.span(),
                );
            });

        (attr, variant)
    });
    attrs.collect()
}

fn write_tag_kind(f: &mut impl std::fmt::Write) {
    for comment in TAG.comments.iter() {
        writeln!(f, "///{comment}").ok();
    }
    writeln!(f, "#[derive(Clone, Debug, PartialEq)]").ok();
    writeln!(f, "pub enum TagKind {{").ok();
    for TagVariant { name, comments, .. } in TAG.variants.iter() {
        for comment in comments.iter() {
            writeln!(f, "    ///{comment}").ok();
        }
        writeln!(f, "    {name}(Tag<{name}>),").ok();
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    writeln!(f, "impl TagKind {{").ok();
    #[rustfmt::skip]
    writeln!(f, "    /// A type erased tag, which allows reading all attributes.").ok();
    writeln!(f, "    pub fn as_any(&self) -> &Tag<()> {{").ok();
    writeln!(f, "        match self {{").ok();
    for TagVariant { name, .. } in TAG.variants.iter() {
        writeln!(f, "            Self::{name}(tag) => tag.as_any(),").ok();
    }
    writeln!(f, "        }}").ok();
    writeln!(f, "    }}").ok();
    writeln!(f).ok();
    #[rustfmt::skip]
    writeln!(f, "    /// A type erased tag, which allows reading all attributes and additionally").ok();
    writeln!(f, "    /// writing all global attributes.").ok();
    writeln!(f, "    pub fn as_any_mut(&mut self) -> &mut Tag<()> {{").ok();
    writeln!(f, "        match self {{").ok();
    for TagVariant { name, .. } in TAG.variants.iter() {
        writeln!(f, "            Self::{name}(tag) => tag.as_any_mut(),").ok();
    }
    writeln!(f, "        }}").ok();
    writeln!(f, "    }}").ok();
    writeln!(f, "}}").ok();

    for variant @ TagVariant { name, .. } in TAG.variants.iter() {
        // Struct definition.
        for comment in variant.comments.iter() {
            writeln!(f, "///{comment}").ok();
        }
        writeln!(f, "#[derive(Clone, Debug, PartialEq)]").ok();
        writeln!(f, "pub struct {name};").ok();
        writeln!(f).ok();

        // From impl.
        writeln!(f, "impl From<Tag<{name}>> for TagKind {{").ok();
        writeln!(f, "    fn from(value: Tag<{name}>) -> Self {{").ok();
        writeln!(f, "        Self::{name}(value)").ok();
        writeln!(f, "    }}").ok();
        writeln!(f, "}}").ok();

        // Constructor and accessors.
        writeln!(f, "impl Tag<{name}> {{").ok();
        for comment in variant.comments.iter() {
            writeln!(f, "    ///{comment}").ok();
        }
        if variant.required.is_empty() && variant.suggested.is_empty() {
            writeln!(f, "    #[allow(non_upper_case_globals)]").ok();
            writeln!(f, "    pub const {name}: Tag<{name}> = Tag::new();").ok();
        } else {
            let params = (variant.required.iter())
                .map(|(_, attr_variant)| {
                    let name = attr_variant.accessor_name();
                    let ty = attr_variant.param_type();
                    format!("{name}: {ty}")
                })
                .chain((variant.suggested.iter()).map(|(_, attr_variant)| {
                    let name = attr_variant.accessor_name();
                    let ty = attr_variant.param_type();
                    format!("{name}: Option<{ty}>")
                }))
                .collect::<Vec<_>>()
                .join(", ");
            writeln!(f, "    #[allow(non_snake_case)]").ok();
            writeln!(f, "    pub fn {name}({params}) -> Tag<{name}> {{").ok();

            writeln!(f, "        let mut tag = Tag::new();").ok();
            for (_, attr_variant) in variant.required.iter() {
                let name = attr_variant.accessor_name();
                writeln!(f, "        tag.set_{name}({name});").ok();
            }
            for (_, attr_variant) in variant.suggested.iter() {
                let name = attr_variant.accessor_name();
                writeln!(f, "        tag.set_{name}({name});").ok();
            }
            writeln!(f, "        tag").ok();

            writeln!(f, "    }}").ok();
        }

        // Generate accessors for tag specific attributes.
        for (i, (attr_kind, attr_variant)) in (variant.required.iter())
            .chain(variant.optional.iter())
            .enumerate()
        {
            if attr_variant.global {
                continue;
            }
            let required = i < variant.required.len();

            write_accessors(f, attr_kind, attr_variant, required, true);
        }

        writeln!(f, "}}").ok();
        writeln!(f).ok();
    }

    writeln!(f, "// Accessors for global attributes, for any tag").ok();
    writeln!(f, "impl<T> Tag<T> {{").ok();
    for attr_kind in ATTRS.values() {
        for attr_variant in attr_kind.variants.iter() {
            if !attr_variant.global {
                continue;
            }

            write_accessors(f, attr_kind, attr_variant, false, true);
        }
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    #[rustfmt::skip]
    writeln!(f, "// Accessors for non-global attributes, for type-erased tag").ok();
    writeln!(f, "impl Tag<()> {{").ok();
    for attr_kind in ATTRS.values() {
        for attr_variant in attr_kind.variants.iter() {
            if attr_variant.global {
                continue;
            }

            write_accessors(f, attr_kind, attr_variant, false, false);
        }
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();
}

fn write_accessors(
    f: &mut impl std::fmt::Write,
    attr_kind: &Attr,
    attr_variant: &AttrVariant,
    required: bool,
    write: bool,
) {
    let kind = attr_kind.name;
    let variant = attr_variant.name;
    let ordinal = attr_variant.ordinal_name();
    let accessor = attr_variant.accessor_name();
    let attr_field = attr_kind.field();
    let param_ty = attr_variant.param_type();
    let param_mapping = attr_variant.param_mapping();
    let ret_ty = attr_variant.return_type();
    writeln!(f).ok();
    for comment in attr_variant.comments.iter() {
        writeln!(f, "    ///{comment}").ok();
    }
    if required {
        writeln!(f, "    pub fn {accessor}(&self) -> {ret_ty} {{").ok();
    } else {
        writeln!(f, "    pub fn {accessor}(&self) -> Option<{ret_ty}> {{").ok();
    }
    let unwrap = if required { ".unwrap()" } else { "" };
    #[rustfmt::skip]
    writeln!(f, "        self.{attr_field}.get::<{{{kind}::{ordinal}}}>().map({kind}::unwrap_{accessor}){unwrap}").ok();
    writeln!(f, "    }}").ok();

    if !write {
        return;
    }

    writeln!(f).ok();
    for comment in attr_variant.comments.iter() {
        writeln!(f, "    ///{comment}").ok();
    }
    #[rustfmt::skip]
    if attr_variant.accessor_kind == AccessorKind::Custom || required {
        writeln!(f, "    pub fn set_{accessor}(&mut self, {accessor}: {param_ty}) {{").ok();
        writeln!(f, "        self.{attr_field}.set({kind}::{variant}({accessor}{param_mapping}));").ok();
    } else {
        writeln!(f, "    pub fn set_{accessor}(&mut self, {accessor}: Option<{param_ty}>) {{").ok();
        writeln!(f, "        self.{attr_field}.set_or_remove::<{{{kind}::{ordinal}}}>({accessor}{param_mapping}.map({kind}::{variant}));").ok();
    };
    writeln!(f, "    }}").ok();
    writeln!(f).ok();

    for comment in attr_variant.comments.iter() {
        writeln!(f, "    ///{comment}").ok();
    }
    #[rustfmt::skip]
    if attr_variant.accessor_kind == AccessorKind::Custom || required {
        writeln!(f, "    pub fn with_{accessor}(mut self, {accessor}: {param_ty}) -> Self {{").ok();
    } else {
        writeln!(f, "    pub fn with_{accessor}(mut self, {accessor}: Option<{param_ty}>) -> Self {{").ok();
    };
    writeln!(f, "        self.set_{accessor}({accessor});").ok();
    writeln!(f, "        self").ok();
    writeln!(f, "    }}").ok();
}

fn write_attr(f: &mut impl std::fmt::Write, attr: &Attr) {
    let kind_name = attr.name;
    writeln!(f, "#[derive(Clone, Debug, PartialEq)]").ok();
    writeln!(f, "pub(crate) enum {kind_name} {{").ok();
    for variant @ AttrVariant { name, ty, .. } in attr.variants.iter() {
        for comment in variant.comments.iter() {
            writeln!(f, "    ///{comment}").ok();
        }
        writeln!(f, "    {name}({ty}),").ok();
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    writeln!(f, "impl {kind_name} {{").ok();
    for (i, variant) in attr.variants.iter().enumerate() {
        let ordinal = variant.ordinal_name();
        #[rustfmt::skip]
        writeln!(f, "    pub(crate) const {ordinal}: usize = {i};").ok();
    }
    for variant @ AttrVariant { name, .. } in attr.variants.iter() {
        let accessor = variant.accessor_name();
        let ret_ty = variant.return_type();
        let ret_mapping = variant.return_mapping();
        writeln!(f).ok();
        writeln!(f, "        #[inline(always)]").ok();
        writeln!(f, "        fn unwrap_{accessor}(&self) -> {ret_ty} {{").ok();
        writeln!(f, "            match self {{").ok();
        #[rustfmt::skip]
        writeln!(f, "                Self::{name}(val) => val{ret_mapping},").ok();
        if attr.variants.len() > 1 {
            writeln!(f, "                _ => unreachable!(),").ok();
        }
        writeln!(f, "            }}").ok();
        writeln!(f, "        }}").ok();
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    writeln!(f, "impl Ordinal for {kind_name} {{").ok();
    writeln!(f, "    fn ordinal(&self) -> usize {{").ok();
    writeln!(f, "        match self {{").ok();
    for variant in attr.variants.iter() {
        let name = variant.name;
        let ordinal = variant.ordinal_name();
        #[rustfmt::skip]
        writeln!(f, "            Self::{name}(_) => Self::{ordinal},").ok();
    }
    writeln!(f, "        }}").ok();
    writeln!(f, "    }}").ok();
    writeln!(f, "}}").ok();
    writeln!(f).ok();
}

trait ExpectKey<'a> {
    fn expect_key(&'a self, key: &str, span: Span) -> &'a MapTableEntry<'a>;
}

impl<'a> ExpectKey<'a> for MapTable<'a> {
    fn expect_key(&'a self, key: &str, span: Span) -> &'a MapTableEntry<'a> {
        let Some(entry) = self.get(key) else {
            report_error(&format!("missing key `{key}`"), span)
        };
        entry
    }
}

trait ExpectValue<'a> {
    fn expect_table(&'a self) -> &'a MapTable<'a>;
    fn expect_inline_array(&'a self) -> &'a MapArrayInline<'a>;
    fn expect_str(&'a self) -> &'a str;
}

impl<'a> ExpectValue<'a> for MapTableEntry<'a> {
    fn expect_table(&'a self) -> &'a MapTable<'a> {
        let MapNode::Table(table) = &self.node else {
            report_error("expected table", self.reprs.first().repr_span());
        };
        table
    }

    fn expect_inline_array(&'a self) -> &'a MapArrayInline<'a> {
        let MapNode::Array(MapArray::Inline(array)) = &self.node else {
            report_error("expected inline array", self.reprs.first().repr_span());
        };
        array
    }

    fn expect_str(&'a self) -> &'a str {
        let MapNode::Scalar(Scalar::String(str)) = &self.node else {
            report_error("expected str", self.reprs.first().repr_span());
        };
        str.text
    }
}

impl<'a> ExpectValue<'a> for MapArrayInlineEntry<'a> {
    fn expect_table(&'a self) -> &'a MapTable<'a> {
        let MapNode::Table(table) = &self.node else {
            report_error("expected table", self.repr.span());
        };
        table
    }

    fn expect_inline_array(&'a self) -> &'a MapArrayInline<'a> {
        let MapNode::Array(MapArray::Inline(array)) = &self.node else {
            report_error("expected inline array", self.repr.span());
        };
        array
    }

    fn expect_str(&'a self) -> &'a str {
        let MapNode::Scalar(Scalar::String(str)) = &self.node else {
            report_error("expected str", self.repr.span());
        };
        str.text
    }
}

fn comment_lines<'a>(repr: &MapTableEntryRepr) -> Vec<&'a str> {
    let comments = repr.kind.comments().unwrap();
    (TOML.ast.direct_comments(comments))
        .filter_map(|(pos, str)| (pos == AssocPos::Above).then_some(&str[1..]))
        .collect()
}

fn report_error(msg: &str, span: Span) -> ! {
    let mut buf = String::new();
    let lines = diagnostic::lines(TOML.input);
    let error = GenError { msg, span };
    diagnostic::display(&mut buf, &error, &lines).ok();
    println!("{buf}");
    std::process::exit(1);
}

struct GenError<'a> {
    span: Span,
    msg: &'a str,
}

impl diagnostic::Diagnostic for GenError<'_> {
    type Hint = GenHint;

    const SEVERITY: diagnostic::Severity = diagnostic::Severity::Error;

    fn span(&self) -> Span {
        self.span
    }

    fn description(&self, f: &mut impl std::fmt::Write) -> std::fmt::Result {
        f.write_str(self.msg)
    }

    fn annotation(&self, f: &mut impl std::fmt::Write) -> std::fmt::Result {
        f.write_str(self.msg)
    }
}

struct GenHint;
impl diagnostic::DiagnosticHint for GenHint {
    fn span(&self) -> Span {
        unreachable!()
    }

    fn annotation(&self, _: &mut impl std::fmt::Write) -> std::fmt::Result {
        unreachable!()
    }
}
