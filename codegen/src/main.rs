use std::sync::{LazyLock, OnceLock};

use convert_case::{Case, Casing};
use crates_common::{diagnostic, Pos, Span};
use crates_toml::container::{Container, Toml};
use crates_toml::map::{
    MapArray, MapArrayInline, MapArrayInlineEntry, MapNode, MapTableEntry, MapTableEntryRepr,
    Scalar,
};
use crates_toml::parse::AssocPos;
use crates_toml::{MapTable, TomlDiagnostics};
use indexmap::IndexMap;

const INPUT_PATH: &str = "crates/krilla/src/interchange/tagging/generate.toml";
const OUTPUT_PATH: &str = "crates/krilla/src/interchange/tagging/generated.rs";
const HEADER: &str = "\
// This file is automatically generated!
//
// To update it:
// 1. Edit the `generate.toml` file inside of this directory
// 2. Run `cargo run --bin=codegen` from the repository root

";

struct Tag<'a> {
    comments: Vec<&'a str>,
    variants: Vec<TagVariant<'a>>,
}

struct TagVariant<'a> {
    comments: Vec<&'a str>,
    name: &'a str,
    required: Vec<(&'a Attr<'a>, &'a AttrVariant<'a>)>,
    optional: Vec<(&'a Attr<'a>, &'a AttrVariant<'a>)>,
    suggested: Vec<(&'a Attr<'a>, &'a AttrVariant<'a>)>,
}

struct Attr<'a> {
    name: &'a str,
    variants: Vec<AttrVariant<'a>>,
    field: OnceLock<&'a str>,
    struct_name: OnceLock<&'a str>,
}

impl Attr<'_> {
    fn struct_name(&self) -> &str {
        self.struct_name
            .get_or_init(|| format!("{}Attr", self.name).leak())
    }

    fn accessor_name(&self) -> &str {
        self.field
            .get_or_init(|| self.name.to_case(Case::Snake).leak())
    }
}

struct AttrVariant<'a> {
    span: Span,
    comments: Vec<&'a str>,
    name: &'a str,
    ty: &'a str,
    global: bool,
    accessor_name: OnceLock<&'a str>,
    accessor_kind: AccessorKind<'a>,
    ordinal_name: OnceLock<&'a str>,
    param_type: OnceLock<&'a str>,
    param_mapping: OnceLock<&'a str>,
    ret_type: OnceLock<&'a str>,
    ret_mapping: OnceLock<&'a str>,
}

impl AttrVariant<'_> {
    fn accessor_name(&self) -> &str {
        self.accessor_name
            .get_or_init(|| self.name.to_case(Case::Snake).leak())
    }

    fn ordinal_name(&self) -> &str {
        self.ordinal_name
            .get_or_init(|| self.name.to_case(Case::UpperSnake).leak())
    }

    fn param_type(&self) -> &str {
        self.param_type.get_or_init(|| match self.accessor_kind {
            AccessorKind::Normal => self.ty,
            AccessorKind::Copy => self.ty,
            AccessorKind::AsRef(_) => self.ty,
            AccessorKind::Custom => match self.name {
                "CellHeaders" => "impl IntoIterator<Item = TagId>",
                #[rustfmt::skip]
                _ => report_error(
                    &format!("no custom parameter type rule implemented for `{}`", self.name),
                    self.span,
                ),
            },
        })
    }

    fn param_mapping(&self) -> &str {
        match self.accessor_kind {
            AccessorKind::Normal | AccessorKind::Copy | AccessorKind::AsRef(_) => {
                self.accessor_name()
            }
            AccessorKind::Custom => self.param_mapping.get_or_init(|| match self.name {
                "CellHeaders" => "headers.map(|ids| ids.into_iter().collect())",
                #[rustfmt::skip]
                _ => report_error(
                    &format!("no custom parameter mapping rule implemented for `{}`", self.name),
                    self.span,
                ),
            }),
        }
    }

    fn return_type(&self) -> &str {
        self.ret_type.get_or_init(|| match self.accessor_kind {
            AccessorKind::Normal => format!("&{}", self.ty).leak(),
            AccessorKind::Copy => self.ty,
            AccessorKind::AsRef(ret) => format!("&{ret}").leak(),
            AccessorKind::Custom => match self.name {
                "CellHeaders" => "&[TagId]",
                #[rustfmt::skip]
                _ => report_error(
                    &format!("no custom return type rule implemented for `{}`", self.name),
                    self.span,
                ),
            },
        })
    }

    fn return_mapping(&self) -> &str {
        self.ret_mapping.get_or_init(|| match self.accessor_kind {
            AccessorKind::Normal => "val",
            AccessorKind::Copy => "*val",
            AccessorKind::AsRef(_) => "val.as_ref()",
            AccessorKind::Custom => match self.name {
                "CellHeaders" => "val.as_ref()",
                #[rustfmt::skip]
                _ => report_error(
                    &format!("no custom return mapping rule implemented for `{}`", self.name),
                    self.span,
                ),
            },
        })
    }
}

#[derive(Default, PartialEq, Eq)]
enum AccessorKind<'a> {
    #[default]
    Normal,
    Copy,
    AsRef(&'a str),
    Custom,
}

static TOML: LazyLock<&Toml> = LazyLock::new(|| {
    let input = std::fs::read_to_string(INPUT_PATH).unwrap();
    let mut ctx = TomlDiagnostics::default();
    let container = Container::parse(&mut ctx, &input);
    if !ctx.is_empty() {
        let mut buf = String::new();
        let lines = diagnostic::lines(&input);
        for error in ctx.errors.iter() {
            diagnostic::display(&mut buf, error, &lines).ok();
        }
        for warning in ctx.warnings.iter() {
            diagnostic::display(&mut buf, warning, &lines).ok();
        }
        for info in ctx.infos.iter() {
            diagnostic::display(&mut buf, info, &lines).ok();
        }
        println!("{buf}");
        std::process::exit(1);
    }
    let container = Box::leak(Box::new(container));
    container.toml()
});

static ATTRS: LazyLock<IndexMap<&str, Attr>> = LazyLock::new(|| {
    TOML.map
        .expect_key("Attr", Span::pos(Pos::ZERO))
        .expect_table()
        .iter()
        .map(|(name, attr)| {
            let attr = parse_attr(name, attr.expect_table());
            (*name, attr)
        })
        .collect()
});
static TAG: LazyLock<Tag> = LazyLock::new(parse_tag);

fn parse_attr<'a>(name: &'a str, attr: &'a MapTable<'a>) -> Attr<'a> {
    let variants = attr.iter().map(|(variant_name, entry)| {
        let span = entry.reprs.first().repr_span();
        let variant = entry.expect_table();
        let ty = variant.expect_key("type", span).expect_str();
        let global = variant.get("global").is_some();
        let accessor_name = OnceLock::new();
        if let Some(e) = variant.get("name") {
            accessor_name.set(e.expect_str()).unwrap();
        }
        let accessor_kind = variant
            .get("accessor")
            .map(|e| match e.expect_str() {
                "Copy" => AccessorKind::Copy,
                "Custom" => AccessorKind::Custom,
                s if s.starts_with("AsRef<") && s.ends_with(">") => {
                    let ret_ty = s.strip_prefix("AsRef<").unwrap().strip_suffix(">").unwrap();
                    AccessorKind::AsRef(ret_ty)
                }
                _ => report_error("unknown accessor kind", e.reprs.first().repr_span()),
            })
            .unwrap_or_default();

        AttrVariant {
            span,
            comments: comment_lines(entry.reprs.first()),
            name: variant_name,
            ty,
            global,
            accessor_name,
            accessor_kind,
            ordinal_name: OnceLock::new(),
            param_type: OnceLock::new(),
            param_mapping: OnceLock::new(),
            ret_type: OnceLock::new(),
            ret_mapping: OnceLock::new(),
        }
    });

    Attr {
        name,
        variants: variants.collect(),
        field: OnceLock::new(),
        struct_name: OnceLock::new(),
    }
}

fn parse_tag() -> Tag<'static> {
    let entry = TOML.map.expect_key("Tag", Span::pos(Pos::ZERO));
    let comments = comment_lines(entry.reprs.first());

    let tag = entry.expect_table();
    let variants = tag.iter().map(|(variant_name, entry)| {
        let comments = comment_lines(entry.reprs.first());
        let variant = entry.expect_table();
        let required = variant.get("required").map(attribute_array);
        let optional = variant.get("optional").map(attribute_array);
        let suggested = variant.get("suggested").map(attribute_array);
        TagVariant {
            comments,
            name: variant_name,
            required: required.unwrap_or_default(),
            optional: optional.unwrap_or_default(),
            suggested: suggested.unwrap_or_default(),
        }
    });

    Tag {
        comments,
        variants: variants.collect(),
    }
}

fn main() {
    let mut output = String::new();
    output.push_str(HEADER);

    write_tag_kind(&mut output);
    write_any_attr(&mut output);
    let mut ordinal_offset = 0;
    for attr in ATTRS.values() {
        write_attr(&mut output, attr, ordinal_offset);
        ordinal_offset += attr.variants.len();
    }

    std::fs::write(OUTPUT_PATH, &output).unwrap();
}

fn attribute_array(
    entry: &MapTableEntry<'_>,
) -> Vec<(&'static Attr<'static>, &'static AttrVariant<'static>)> {
    let array = entry.expect_inline_array();
    let attrs = array.iter().map(|e| {
        let Some((attr_kind, attr_variant)) = e.expect_str().split_once("::") else {
            report_error(
                "expected `<attr-kind>::<attr-variant>`, for example `LayoutAttr::BBox`",
                e.repr.span(),
            )
        };

        let Some(attr) = ATTRS.get(attr_kind) else {
            report_error(
                &format!("Unknown attribute kind `{attr_kind}`"),
                e.repr.span(),
            );
        };

        let variant = attr
            .variants
            .iter()
            .find(|v| v.name == attr_variant)
            .unwrap_or_else(|| {
                report_error(
                    &format!("Unknown attribute variant `{attr_kind}::{attr_variant}`"),
                    e.repr.span(),
                );
            });

        (attr, variant)
    });
    attrs.collect()
}

fn write_tag_kind(f: &mut impl std::fmt::Write) {
    for comment in TAG.comments.iter() {
        writeln!(f, "///{comment}").ok();
    }
    writeln!(f, "#[derive(Clone, Debug, PartialEq)]").ok();
    writeln!(f, "pub enum TagKind {{").ok();
    for TagVariant { name, comments, .. } in TAG.variants.iter() {
        for comment in comments.iter() {
            writeln!(f, "    ///{comment}").ok();
        }
        writeln!(f, "    {name}(Tag<kind::{name}>),").ok();
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    writeln!(f, "impl TagKind {{").ok();
    #[rustfmt::skip]
    writeln!(f, "    /// A type erased tag, which allows reading all attributes.").ok();
    writeln!(f, "    pub fn as_any(&self) -> &AnyTag {{").ok();
    writeln!(f, "        match self {{").ok();
    for TagVariant { name, .. } in TAG.variants.iter() {
        writeln!(f, "            Self::{name}(tag) => tag.as_any(),").ok();
    }
    writeln!(f, "        }}").ok();
    writeln!(f, "    }}").ok();
    writeln!(f).ok();
    #[rustfmt::skip]
    writeln!(f, "    /// A type erased tag, which allows reading all attributes and additionally").ok();
    writeln!(f, "    /// writing all global attributes.").ok();
    writeln!(f, "    pub fn as_any_mut(&mut self) -> &mut AnyTag {{").ok();
    writeln!(f, "        match self {{").ok();
    for TagVariant { name, .. } in TAG.variants.iter() {
        writeln!(f, "            Self::{name}(tag) => tag.as_any_mut(),").ok();
    }
    writeln!(f, "        }}").ok();
    writeln!(f, "    }}").ok();

    // Accessors for `TagKind`.
    for attr_kind in ATTRS.values() {
        for attr_variant in attr_kind.variants.iter() {
            let write = attr_variant.global;
            write_accessors(f, attr_kind, attr_variant, false, write, TagImpl::TagKind);
        }
    }

    writeln!(f, "}}").ok();
    writeln!(f).ok();

    // Accessors for `AnyTag`.
    #[rustfmt::skip]
    writeln!(f, "// Read accessors for all attributes and write accessors for global ones.").ok();
    writeln!(f, "impl AnyTag {{").ok();
    for (name, attr) in ATTRS.iter() {
        let struct_name = attr.struct_name();
        let accessor = attr.accessor_name();
        writeln!(f, "    #[inline(always)]").ok();
        #[rustfmt::skip]
        writeln!(f, "    fn get_{accessor}(&self, ordinal: usize) -> Option<&{struct_name}> {{").ok();
        #[rustfmt::skip]
        writeln!(f, "        self.attrs.get(ordinal).map(Attr::unwrap_{accessor})").ok();
        writeln!(f, "    }}").ok();
        writeln!(f).ok();
        writeln!(f, "    #[allow(unused)]").ok();
        writeln!(f, "    #[inline(always)]").ok();
        #[rustfmt::skip]
        writeln!(f, "    fn set_{accessor}(&mut self, attr: {struct_name}) {{").ok();
        writeln!(f, "        self.attrs.set(Attr::{name}(attr));").ok();
        writeln!(f, "    }}").ok();
        writeln!(f).ok();
        writeln!(f, "    #[allow(unused)]").ok();
        writeln!(f, "    #[inline(always)]").ok();
        #[rustfmt::skip]
        writeln!(f, "    fn set_or_remove_{accessor}(&mut self, ordinal: usize, attr: Option<{struct_name}>) {{").ok();
        #[rustfmt::skip]
        writeln!(f, "        self.attrs.set_or_remove(ordinal, attr.map(Attr::{name}));").ok();
        writeln!(f, "    }}").ok();
        writeln!(f).ok();
    }
    for attr_kind in ATTRS.values() {
        for attr_variant in attr_kind.variants.iter() {
            let write = attr_variant.global;
            write_accessors(f, attr_kind, attr_variant, false, write, TagImpl::Any);
        }
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    // Accessors for global attributes.
    writeln!(f, "impl<T> Tag<T> {{").ok();
    for attr_kind in ATTRS.values() {
        for attr_variant in attr_kind.variants.iter() {
            if !attr_variant.global {
                continue;
            }

            write_accessors(f, attr_kind, attr_variant, false, true, TagImpl::Tag);
        }
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    writeln!(f, "/// Tag kind structs.").ok();
    writeln!(f, "pub mod kind {{").ok();
    for variant @ TagVariant { name, .. } in TAG.variants.iter() {
        // Struct definition.
        for comment in variant.comments.iter() {
            writeln!(f, "    ///{comment}").ok();
        }
        writeln!(f, "    #[derive(Clone, Debug, PartialEq)]").ok();
        writeln!(f, "    pub struct {name};").ok();
        writeln!(f).ok();
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    for variant @ TagVariant { name, .. } in TAG.variants.iter() {
        // From impl.
        writeln!(f, "impl From<Tag<kind::{name}>> for TagKind {{").ok();
        writeln!(f, "    fn from(value: Tag<kind::{name}>) -> Self {{").ok();
        writeln!(f, "        Self::{name}(value)").ok();
        writeln!(f, "    }}").ok();
        writeln!(f, "}}").ok();

        // Constructor
        writeln!(f, "impl Tag<kind::{name}> {{").ok();
        for comment in variant.comments.iter() {
            writeln!(f, "    ///{comment}").ok();
        }
        if variant.required.is_empty() && variant.suggested.is_empty() {
            writeln!(f, "    #[allow(non_upper_case_globals)]").ok();
            writeln!(f, "    pub const {name}: Tag<kind::{name}> = Tag::new();").ok();
        } else {
            let params = (variant.required.iter())
                .map(|(_, attr_variant)| {
                    let name = attr_variant.accessor_name();
                    let ty = attr_variant.param_type();
                    format!("{name}: {ty}")
                })
                .chain((variant.suggested.iter()).map(|(_, attr_variant)| {
                    let name = attr_variant.accessor_name();
                    let ty = attr_variant.param_type();
                    format!("{name}: Option<{ty}>")
                }))
                .collect::<Vec<_>>()
                .join(", ");
            writeln!(f, "    #[allow(non_snake_case)]").ok();
            writeln!(f, "    pub fn {name}({params}) -> Tag<kind::{name}> {{").ok();
            writeln!(f, "        let mut tag = Tag::new();").ok();
            for (_, attr_variant) in variant.required.iter().chain(variant.suggested.iter()) {
                let name = attr_variant.accessor_name();
                writeln!(f, "        tag.set_{name}({name});").ok();
            }
            writeln!(f, "        tag").ok();
            writeln!(f, "    }}").ok();
        }

        // Accessors for tag specific attributes.
        for (attr_kind, attr_variant) in variant.required.iter() {
            if attr_variant.global {
                continue;
            }
            write_accessors(f, attr_kind, attr_variant, true, true, TagImpl::Tag);
        }
        for (attr_kind, attr_variant) in variant.optional.iter() {
            if attr_variant.global {
                continue;
            }
            write_accessors(f, attr_kind, attr_variant, false, true, TagImpl::Tag);
        }

        writeln!(f, "}}").ok();
        writeln!(f).ok();
    }
}

#[derive(PartialEq, Eq)]
enum TagImpl {
    TagKind,
    Tag,
    Any,
}

fn write_accessors(
    f: &mut impl std::fmt::Write,
    attr_kind: &Attr,
    attr_variant: &AttrVariant,
    required: bool,
    write: bool,
    tag_impl: TagImpl,
) {
    let kind = attr_kind.struct_name();
    let kind_accessor = attr_kind.accessor_name();
    let variant = attr_variant.name;
    let accessor = attr_variant.accessor_name();
    let ordinal = attr_variant.ordinal_name();
    let param_ty = attr_variant.param_type();
    let param_mapping = attr_variant.param_mapping();
    let ret_ty = attr_variant.return_type();
    writeln!(f).ok();
    for comment in attr_variant.comments.iter() {
        writeln!(f, "    ///{comment}").ok();
    }
    if required {
        writeln!(f, "    pub fn {accessor}(&self) -> {ret_ty} {{").ok();
    } else {
        writeln!(f, "    pub fn {accessor}(&self) -> Option<{ret_ty}> {{").ok();
    }
    let tag = match tag_impl {
        TagImpl::TagKind => "self.as_any()",
        TagImpl::Tag => "self.inner",
        TagImpl::Any => "self",
    };
    if tag_impl == TagImpl::TagKind {
        writeln!(f, "        {tag}.{accessor}()").ok();
    } else {
        #[rustfmt::skip]
        write!(f, "        {tag}.get_{kind_accessor}({kind}::{ordinal})").ok();
        if required {
            writeln!(f, ".unwrap().unwrap_{accessor}()").ok();
        } else {
            writeln!(f, ".map({kind}::unwrap_{accessor})").ok();
        }
    }
    writeln!(f, "    }}").ok();

    if !write {
        return;
    }

    writeln!(f).ok();
    let tag = match tag_impl {
        TagImpl::TagKind => "self.as_any_mut()",
        TagImpl::Tag => "self.inner",
        TagImpl::Any => "self",
    };
    write_setter_comment(f, &attr_variant.comments);
    #[rustfmt::skip]
    if required {
        writeln!(f, "    pub fn set_{accessor}(&mut self, {accessor}: {param_ty}) {{").ok();
    } else {
        writeln!(f, "    pub fn set_{accessor}(&mut self, {accessor}: Option<{param_ty}>) {{").ok();
    };
    if tag_impl == TagImpl::TagKind {
        writeln!(f, "        {tag}.set_{accessor}({accessor});").ok();
    } else if required {
        #[rustfmt::skip]
        writeln!(f, "        {tag}.set_{kind_accessor}({kind}::{variant}({param_mapping}));").ok();
    } else {
        #[rustfmt::skip]
        writeln!(f, "        {tag}.set_or_remove_{kind_accessor}({kind}::{ordinal}, {param_mapping}.map({kind}::{variant}));").ok();
    }
    writeln!(f, "    }}").ok();
    writeln!(f).ok();

    write_setter_comment(f, &attr_variant.comments);
    #[rustfmt::skip]
    if required {
        writeln!(f, "    pub fn with_{accessor}(mut self, {accessor}: {param_ty}) -> Self {{").ok();
    } else {
        writeln!(f, "    pub fn with_{accessor}(mut self, {accessor}: Option<{param_ty}>) -> Self {{").ok();
    };
    writeln!(f, "        self.set_{accessor}({accessor});").ok();
    writeln!(f, "        self").ok();
    writeln!(f, "    }}").ok();
}

fn write_setter_comment(f: &mut impl std::fmt::Write, comments: &[&str]) {
    if let Some(comment) = comments.first() {
        let line = comment.trim_start();
        let first = line.chars().next().unwrap();
        let remainder = &line[first.len_utf8()..];
        writeln!(f, "    /// Set {}{remainder}", first.to_lowercase()).ok();
    }
    for comment in comments.iter().skip(1) {
        writeln!(f, "    ///{comment}").ok();
    }
}

fn write_any_attr(f: &mut impl std::fmt::Write) {
    writeln!(f, "#[derive(Clone, Debug, PartialEq)]").ok();
    writeln!(f, "pub(crate) enum Attr {{").ok();
    for (kind, attr) in ATTRS.iter() {
        let struct_name = attr.struct_name();
        writeln!(f, "    {kind}({struct_name}),").ok();
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    writeln!(f, "impl Attr {{").ok();
    for (name, attr) in ATTRS.iter() {
        let struct_name = attr.struct_name();
        let accessor = attr.accessor_name();
        writeln!(f).ok();
        writeln!(f, "        #[inline(always)]").ok();
        writeln!(
            f,
            "        fn unwrap_{accessor}(&self) -> &{struct_name} {{"
        )
        .ok();
        writeln!(f, "            match self {{").ok();
        #[rustfmt::skip]
        writeln!(f, "                Self::{name}(attr) => attr,").ok();
        writeln!(f, "                _ => unreachable!(),").ok();
        writeln!(f, "            }}").ok();
        writeln!(f, "        }}").ok();
    }
    writeln!(f, "}}").ok();

    writeln!(f, "impl Ordinal for Attr {{").ok();
    writeln!(f, "    fn ordinal(&self) -> usize {{").ok();
    writeln!(f, "        match self {{").ok();
    for attr in ATTRS.keys() {
        writeln!(f, "            Self::{attr}(a) => a.ordinal(),").ok();
    }
    writeln!(f, "        }}").ok();
    writeln!(f, "    }}").ok();
    writeln!(f, "}}").ok();
    writeln!(f).ok();
}

fn write_attr(f: &mut impl std::fmt::Write, attr: &Attr, ordinal_offset: usize) {
    let struct_name = attr.struct_name();
    writeln!(f, "#[derive(Clone, Debug, PartialEq)]").ok();
    writeln!(f, "pub(crate) enum {struct_name} {{").ok();
    for variant @ AttrVariant { name, ty, .. } in attr.variants.iter() {
        for comment in variant.comments.iter() {
            writeln!(f, "    ///{comment}").ok();
        }
        writeln!(f, "    {name}({ty}),").ok();
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    writeln!(f, "impl {struct_name} {{").ok();
    for (i, variant) in attr.variants.iter().enumerate() {
        let o = ordinal_offset + i;
        let ordinal = variant.ordinal_name();
        #[rustfmt::skip]
        writeln!(f, "    pub(crate) const {ordinal}: usize = {o};").ok();
    }
    for variant @ AttrVariant { name, .. } in attr.variants.iter() {
        let accessor = variant.accessor_name();
        let ret_ty = variant.return_type();
        let ret_mapping = variant.return_mapping();
        writeln!(f).ok();
        writeln!(f, "        #[inline(always)]").ok();
        writeln!(f, "        fn unwrap_{accessor}(&self) -> {ret_ty} {{").ok();
        writeln!(f, "            match self {{").ok();
        #[rustfmt::skip]
        writeln!(f, "                Self::{name}(val) => {ret_mapping},").ok();
        if attr.variants.len() > 1 {
            writeln!(f, "                _ => unreachable!(),").ok();
        }
        writeln!(f, "            }}").ok();
        writeln!(f, "        }}").ok();
    }
    writeln!(f, "}}").ok();
    writeln!(f).ok();

    writeln!(f, "impl Ordinal for {struct_name} {{").ok();
    writeln!(f, "    fn ordinal(&self) -> usize {{").ok();
    writeln!(f, "        match self {{").ok();
    for variant in attr.variants.iter() {
        let name = variant.name;
        let ordinal = variant.ordinal_name();
        #[rustfmt::skip]
        writeln!(f, "            Self::{name}(_) => Self::{ordinal},").ok();
    }
    writeln!(f, "        }}").ok();
    writeln!(f, "    }}").ok();
    writeln!(f, "}}").ok();
    writeln!(f).ok();
}

trait ExpectKey<'a> {
    fn expect_key(&'a self, key: &str, span: Span) -> &'a MapTableEntry<'a>;
}

impl<'a> ExpectKey<'a> for MapTable<'a> {
    fn expect_key(&'a self, key: &str, span: Span) -> &'a MapTableEntry<'a> {
        let Some(entry) = self.get(key) else {
            report_error(&format!("missing key `{key}`"), span)
        };
        entry
    }
}

trait ExpectValue<'a> {
    fn expect_table(&'a self) -> &'a MapTable<'a>;
    fn expect_inline_array(&'a self) -> &'a MapArrayInline<'a>;
    fn expect_str(&'a self) -> &'a str;
}

impl<'a> ExpectValue<'a> for MapTableEntry<'a> {
    fn expect_table(&'a self) -> &'a MapTable<'a> {
        let MapNode::Table(table) = &self.node else {
            report_error("expected table", self.reprs.first().repr_span());
        };
        table
    }

    fn expect_inline_array(&'a self) -> &'a MapArrayInline<'a> {
        let MapNode::Array(MapArray::Inline(array)) = &self.node else {
            report_error("expected inline array", self.reprs.first().repr_span());
        };
        array
    }

    fn expect_str(&'a self) -> &'a str {
        let MapNode::Scalar(Scalar::String(str)) = &self.node else {
            report_error("expected str", self.reprs.first().repr_span());
        };
        str.text
    }
}

impl<'a> ExpectValue<'a> for MapArrayInlineEntry<'a> {
    fn expect_table(&'a self) -> &'a MapTable<'a> {
        let MapNode::Table(table) = &self.node else {
            report_error("expected table", self.repr.span());
        };
        table
    }

    fn expect_inline_array(&'a self) -> &'a MapArrayInline<'a> {
        let MapNode::Array(MapArray::Inline(array)) = &self.node else {
            report_error("expected inline array", self.repr.span());
        };
        array
    }

    fn expect_str(&'a self) -> &'a str {
        let MapNode::Scalar(Scalar::String(str)) = &self.node else {
            report_error("expected str", self.repr.span());
        };
        str.text
    }
}

fn comment_lines<'a>(repr: &MapTableEntryRepr) -> Vec<&'a str> {
    let comments = repr.kind.comments().unwrap();
    (TOML.ast.direct_comments(comments))
        .filter_map(|(pos, str)| (pos == AssocPos::Above).then_some(&str[1..]))
        .collect()
}

fn report_error(msg: &str, span: Span) -> ! {
    let mut buf = String::new();
    let lines = diagnostic::lines(TOML.input);
    let error = GenError { msg, span };
    diagnostic::display(&mut buf, &error, &lines).ok();
    println!("{buf}");
    std::process::exit(1);
}

struct GenError<'a> {
    span: Span,
    msg: &'a str,
}

impl diagnostic::Diagnostic for GenError<'_> {
    type Hint = GenHint;

    const SEVERITY: diagnostic::Severity = diagnostic::Severity::Error;

    fn span(&self) -> Span {
        self.span
    }

    fn description(&self, f: &mut impl std::fmt::Write) -> std::fmt::Result {
        f.write_str(self.msg)
    }

    fn annotation(&self, f: &mut impl std::fmt::Write) -> std::fmt::Result {
        f.write_str(self.msg)
    }
}

struct GenHint;
impl diagnostic::DiagnosticHint for GenHint {
    fn span(&self) -> Span {
        unreachable!()
    }

    fn annotation(&self, _: &mut impl std::fmt::Write) -> std::fmt::Result {
        unreachable!()
    }
}
